<!--
#	VRxAR Labs | 3D Radar Chart Collaboration Explorer
#
#	Author: Nico Reski
#	Email: nico.reski@lnu.se
#	Web: https://vrxar.lnu.se/apps/tdrc-collab-explore/
#
#	Dependencies:
#	* JavaScript WebSocket WebAPI: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
#   * D3.js version: 5.0.0
#	* TopoJSON version: 3.0.2
-->

<!DOCTYPE html>

<html lang="en">

<head>
	<meta charset="utf-8">
	<title>VRxAR Labs | 3D Radar Chart Collaboration Explorer</title>
	<script src="lib/d3/d3.min.js" charset="utf-8"></script>
	<script src="lib/topojson/topojson@3.js" charset="utf-8"></script> 


	<style>
		/* CSS Tutorial: [https://www.w3schools.com/css/] */
		text {
			font-family: "Avenir Next", "Helvetica  Neue", Helvetica, Arial, sans-serif;
			font-size: 11px;
	  		text-anchor: middle;
		}

		.title {
			font-family: "Avenir Next", "Helvetica  Neue", Helvetica, Arial, sans-serif;
			font-size: 18px;
			margin-left: 10px;
		}

		/* SVG Attribute reference: [https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute] */
		svg {
			font-family: "Avenir Next", "Helvetica  Neue", Helvetica, Arial, sans-serif;
			font-size: 11px;
		}

		/* MAP VIEW */

		/*.country {
            fill: #ebebeb80;
            stroke: #c0c0c0;
            stroke-width: 0.5px;
        }*/

        .country {
            fill: #fff7bc80;
            stroke: #c0c0c0;
            stroke-width: 0.5px;
        } 

        .nordiccountry {
            fill: #f0f0f0;
            stroke: #c0c0c0;
            stroke-width: 0.5px;
        } 

		.clustercircle {
	  		fill-opacity: .8;
	  		stroke: #FFFFFF;
	  		stroke-width: 1px;
		}

		.clustercircle:hover {
			/*fill: #9c9c9c;
	  		fill-opacity: 1;*/
	  		stroke: #000000;
	  		stroke-width: 2px;
		}

		.clustercirclecapital {
	  		fill-opacity: .8;
	  		stroke: #000000;
	  		stroke-width: 2px;
		}

		.clustercirclecapital:hover {
			fill: #000000;
	  		fill-opacity: 1;
		}

		#selectedClusterCircle {
			/*stroke: #5e5e5e;
			stroke-width: 2px;*/
			stroke: #fb6a4a;
	  		stroke-width: 4px;
		}

		#selectedClusterCircle:hover {
	  		stroke: #000000;
	  		stroke-width: 2px;
		}

		.vrusercircle {
	  		fill-opacity: .8;
	  		stroke: #000000;
	  		stroke-width: 1px;
		}

		#vrUserSelectedClusterCircle {
			/*stroke: #cc4c02;*/
			fill: #b2df8a;
			stroke-width: 2px;
		}


		/* TEMPERATURE VIEW */

		#temperatureViewChartLine {
		    fill: none;
		    stroke: #ff7f00;
		    stroke-width: 3;
		}

		#temperatureViewMouseOverLine {
			stroke-width: 1px;
			stroke: #fcbba1;
			stroke-dasharray: 4px 4px;
		}

		#temperatureViewMouseOverText {
  			font: 12px "Avenir Next";
  			text-anchor: start;
  			fill: #fcbba1;
		}

		#temperatureViewSelectedDateLine {
			stroke-width: 1px;
			stroke: #a50f15;
			stroke-dasharray: 10px 10px;
		}

		#temperatureViewSelectedDateText {
  			font: 12px "Avenir Next";
  			text-anchor: start;
  			fill: #a50f15;
		}

		#temperatureViewSelectedRangeDateLine {
			stroke-width: 1px;
			stroke: #a50f15;
			stroke-dasharray: 10px 10px;
		}

		#temperatureViewSelectedRangeDateText {
  			font: 12px "Avenir Next";
  			text-anchor: start;
  			fill: #a50f15;
		}

		#temperatureViewTimeRangeSelectionRect {
			fill: #fb6a4a;
			fill-opacity: 0.4;
		}


		/* HUMIDITY VIEW */

		#humidityViewChartLine {
		    fill: none;
		    stroke: #1f78b4;
		    stroke-width: 3;
		}

		#humidityViewMouseOverLine {
			stroke-width: 1px;
			stroke: #fcbba1;
			stroke-dasharray: 4px 4px;
		}

		#humidityViewMouseOverText {
  			font: 12px "Avenir Next";
  			text-anchor: start;
  			fill: #fcbba1;
		}

		#humidityViewSelectedDateLine {
			stroke-width: 1px;
			stroke: #a50f15;
			stroke-dasharray: 10px 10px;
		}

		#humidityViewSelectedDateText {
  			font: 12px "Avenir Next";
  			text-anchor: start;
  			fill: #a50f15;
		}

		#humidityViewSelectedRangeDateLine {
			stroke-width: 1px;
			stroke: #a50f15;
			stroke-dasharray: 10px 10px;
		}

		#humidityViewSelectedRangeDateText {
  			font: 12px "Avenir Next";
  			text-anchor: start;
  			fill: #a50f15;
		}

		#humidityViewTimeRangeSelectionRect {
			fill: #fb6a4a;
			fill-opacity: 0.4;
		}


		/* VR in TEMPERATURE AND HUMIDITY VIEW */

		#VRtemperatureViewSelectedDateLine {
			stroke-width: 1px;
			stroke: #33a02c;
			stroke-dasharray: 2px 4px;
		}

		#VRtemperatureViewSelectedRangeStartDateLine {
			stroke-width: 1px;
			stroke: #33a02c;
			stroke-dasharray: 2px 4px;
		}

		#VRtemperatureViewSelectedRangeEndDateLine {
			stroke-width: 1px;
			stroke: #33a02c;
			stroke-dasharray: 2px 4px;
		}

		#VRtemperatureViewSelectedRangeRect {
			fill: #b2df8a;
			fill-opacity: 0.4;
		}

		#VRhumidityViewSelectedDateLine {
			stroke-width: 1px;
			stroke: #33a02c;
			stroke-dasharray: 2px 4px;
		}

		#VRhumidityViewSelectedRangeStartDateLine {
			stroke-width: 1px;
			stroke: #33a02c;
			stroke-dasharray: 2px 4px;
		}

		#VRhumidityViewSelectedRangeEndDateLine {
			stroke-width: 1px;
			stroke: #33a02c;
			stroke-dasharray: 2px 4px;
		}

		#VRhumidityViewSelectedRangeRect {
			fill: #b2df8a;
			fill-opacity: 0.4;
		}


		/* DIV styling for arranging all views */

		#temperatureview {
			width: 950px;
			float: left;
			margin-left: 10px;
			margin-top: 10px;
		}

		/*
		#mapview {
			width: 850px;
			float: left;
			margin-left: 10px;
			margin-top: 10px;
		}
		*/

		/*COLLABORATION-STUDY-IMAC-SETUP*/
		#mapview {
			width: 1550px;
			float: right; /*COLLABORATION-STUDY-IMAC-SETUP*/
			margin-left: 10px;
			margin-top: 10px;
		}

		#humidityview {
			width: 950px;
			float: left;
			margin-left: 10px;
			margin-top: 10px;
		}

	</style>
</head>

<body>
	
	<!-- Initialize HTML DOM tree elements. -->
	<div class="title">VRxAR Labs | 3D Radar Chart Collaboration Explorer</div>
	<p>

	<div id="temperatureview"></div>
	<div id="mapview"></div>
	<div id="humidityview"></div>


	<!-- D3.js visualization implementation. -->
	<script>

	// === DATA LOADING SWITCH ===
	// default -> 03_warmup_collaboration
	// ?data=fruits -> 04_task_collaboration_fruits
	// ?data=vegetables -> 05_task_collaboration_vegetables

	var appURLString = window.location.href;						// grab url that was used to open this web app
	var appURL = new URL(appURLString);								// create URL object
	
	var globalDataDirectory = "data/03_warmup_collaboration/"
	var urlArgData = appURL.searchParams.get("data");				// extract url argument "data"
	if (urlArgData == "fruits")
	{
		globalDataDirectory = "data/04_task_collaboration_fruits/"
	}
	else if (urlArgData == "vegetables")
	{
		globalDataDirectory = "data/05_task_collaboration_vegetables/"
	}
	console.log("Loading data from: " + globalDataDirectory);

	// ===== WEBSOCKET MESSAGE API =====

	// Define string variables for WebSocket event listeners.

	// WebClient (out) -> WebSocketServer (inc/out) -> Unity3D (inc)
	//var collab_js2unitySpatialRefElementaryTask 	= "collab_js_to_unity-spatial_ref-elementary_task";
	//var collab_js2unitySpatialRefSynopticTask 		= "collab_js_to_unity-spatial_ref-synoptic_task";
	//var collab_js2unityTemporalRefElementaryTask 	= "collab_js_to_unity-temporal_ref-elementary_task";
	//var collab_js2unityTemporalRefSynopticTask 		= "collab_js_to_unity-temporal_ref-synopticelementary_task";
	//var collab_js2unityRemoveAllSpatialRef			= "collab_js_to_unity-remove_all_spatial_ref";
	//var collab_js2unityRemoveAllTemporalRef			= "collab_js_to_unity-remove_all_temporal_ref";

	// WebClient (out) -> WebSocketServer (inc/out) -> Unity3D (inc)
	var collab_js2unitySpatialRefElementaryTask 	= "collab_js_to_unity-spatial_ref-elementary_task";				// select country location --> spatial ref, elementary task
	var collab_js2unityTemporalRefElementaryTask	= "collab_js_to_unity-temporal_ref-elementary_task";			// select time event (at currently selected location) --> temporal ref, elementary task
	var collab_js2unityTemporalRefSynopticTask 		= "collab_js_to_unity-temporal_ref-synopticelementary_task";	// select time range (at currently selected location) --> temporal ref, synoptic task

	// Unity3D (out) -> WebSocketServer (inc/out) ->  WebClient (inc)
	var collab_unity2jsVRUserTransformUpdate = "collab_unity_to_js-transform_update";		// VR user transform (position + rotation) update
	var collab_unity2jsLocationUpdate 		 = "collab_unity_to_js-location_update";		// VR user's 3D Radar Chart that is currently active and in focus
	var collab_unity2jsTimeEventUpdate 		 = "collab_unity_to_js-time_event_update";		// VR user's currently selected time event (= time slice)
	var collab_unity2jsTimeRangeUpdate 		 = "collab_unity_to_js-time_range_update";		// VR user's currently selected time range

	// ===== WEBSOCKET SETUP AND EVENT LISTERNERS =====

	// create websocket instance
	//const socket = new WebSocket('wss://MY_SERVER_URL:MY_SERVER_PORT/');
	const socket = new WebSocket('wss://vrxar.lnu.se:4247/');

	var shouldConnectToWebSocketServer = false;		// default setting: do not connnect to websocket server

	// decide whether the web app should connect to the websocket server or not via url argument
	// standard (no websocket server connection): 	[ https://vrxar.lnu.se/apps/tdrc-collab-explore/ ]
	// with websocket server connection: 			[ https://vrxar.lnu.se/apps/tdrc-collab-explore/?wssconnect=true ]

	var wssConnect = appURL.searchParams.get("wssconnect");			// extract url argument "wssconnect"
	if(wssConnect == "true") shouldConnectToWebSocketServer = true;	// set connect to websocket server flag if url argument was set accordingly

	if(shouldConnectToWebSocketServer)
	{
		// Event Handler: Open
		socket.addEventListener('open', function (event) {
			console.log("Connection established to WSS Server.");
		});

		// Event Handler: Message
		socket.addEventListener('message', function (event) {

			//console.log("Message recevied with data: " + event.data);

			var receivedJsonMessage = JSON.parse(event.data);
			//console.log(receivedJsonMessage.api);

			switch(receivedJsonMessage.api)
			{
				case collab_unity2jsVRUserTransformUpdate:
					//console.log("VR user transform update: " + receivedJsonMessage.posX + " | " + receivedJsonMessage.posZ + " | " + receivedJsonMessage.rotY);

					updateVRUserNode(receivedJsonMessage.posX, receivedJsonMessage.posZ, receivedJsonMessage.rotY);
					break;

				case collab_unity2jsLocationUpdate:
					//console.log("VR selected location: " + receivedJsonMessage.tdrcWithName);

					lastVRUserSelectedTimeEvent = null;
					lastVRUserSelectedTimeRangeStart = null;
					lastVRUserSelectedTimeRangeEnd = null;

					VR_updateSelectedLocation(receivedJsonMessage.tdrcWithName);
					break;

				case collab_unity2jsTimeEventUpdate:
					//console.log("VR selected time event in location: " + receivedJsonMessage.tdrcWithName + " : " + receivedJsonMessage.pointInTime);

					VR_removeTimeEventInformation();
					VR_updateSelectedTimeEvent(receivedJsonMessage.pointInTime);
					break;

				case collab_unity2jsTimeRangeUpdate:
					//console.log("VR selected time range in location: " + receivedJsonMessage.tdrcWithName + " : " + receivedJsonMessage.pointInTimeFrom + "  <--->  " + receivedJsonMessage.pointInTimeTo);

					VR_removeTimeRangeInformation();
					VR_updateSelectedTimeRange(receivedJsonMessage.pointInTimeFrom, receivedJsonMessage.pointInTimeTo);
					break;

				default:
					break;
			}

		});
	}

	// ===== JS TO UNITY FUNCTIONS =====
	function networking_js2unity_spatialReferenceSingle(location)
	{
		// WEBSOCKET CONNECTION
		if (shouldConnectToWebSocketServer && socket.readyState == WebSocket.OPEN)
		{
			// Reference Variant Definitions:
			// spatRef_a, spatRef_b, spatRef_c

			// construct an example DefaultMessage (see properties in class WebSockerServerConnector.MessageJSONAPI.DefaultMessage in Unity3D source code)
			var jsonDefaultMessage = { 'sender' : 'JS_Web_External_Collaborator_client',
									   'receiver' : 'Unity3D_3D_Radar_Chart_client',
									   'api': collab_js2unitySpatialRefElementaryTask,
									   'referenceVariant' : 'spatRef_b',
									   'tdrcWithName' : location };

			// create JSON string based on message object's keys and values
			var jsonString = JSON.stringify(jsonDefaultMessage);

			// send string to WebSocket server
			socket.send(jsonString);
		}
	}

	function networking_js2unity_temporalReferenceSingle(location, timeEvent)
	{
		// Reference Variant Definitions:
		// tempRef_a, tempRef_b, tempRef_c

		const referenceVariant = 'tempRef_d';
		var selectedIndicator = "";
		//if (referenceVariant == "tempRef_c") selectedIndicator = selectedIndicatorPoint;
		//else if (referenceVariant == "tempRef_d") selectedIndicator = selectedIndicatorImagePlane;
		// console.log("Single Temporal Ref to: " + selectedPointInTime + " | in 3D Radar Chart: " + selectedLocation);

		// WEBSOCKET CONNECTION
		if (shouldConnectToWebSocketServer && socket.readyState == WebSocket.OPEN)
		{
			// construct an example DefaultMessage (see properties in class WebSockerServerConnector.MessageJSONAPI.DefaultMessage in Unity3D source code)
			var jsonDefaultMessage = { 'sender' : 'JS_Web_External_Referencing_client',
									   'receiver' : 'Unity3D_3D_Radar_Chart_client',
									   'api': collab_js2unityTemporalRefElementaryTask,
									   'referenceVariant' : referenceVariant,
									   'tdrcWithName' : location,
									   'pointInTime' : timeEvent,
									   'dimension' : 'all',
									   'referenceIndicator' : selectedIndicator };

			// create JSON string based on message object's keys and values
			var jsonString = JSON.stringify(jsonDefaultMessage);

			// send string to WebSocket server
			socket.send(jsonString);
		}
	}

	function networking_js2unity_temporalReferenceRange(location, timeRangeStart, timeRangeEnd)
	{
		// Reference Variant Definitions:
		// tempRef_a, tempRef_b, tempRef_c

		const referenceVariant = 'tempRef_d';
		var selectedIndicator = "";
		//if (referenceVariant == "tempRef_c") selectedIndicator = selectedIndicatorPoint;
		//else if (referenceVariant == "tempRef_d") selectedIndicator = selectedIndicatorImagePlane;
		// console.log("Range Temporal Ref from " + selectedPointInTimeFrom + " to: " + selectedPointInTimeTo + " | in 3D Radar Chart: " + selectedLocation);

		// WEBSOCKET CONNECTION
		if (shouldConnectToWebSocketServer && socket.readyState == WebSocket.OPEN)
		{
			// construct an example DefaultMessage (see properties in class WebSockerServerConnector.MessageJSONAPI.DefaultMessage in Unity3D source code)
			var jsonDefaultMessage = { 'sender' : 'JS_Web_External_Referencing_client',
									   'receiver' : 'Unity3D_3D_Radar_Chart_client',
									   'api': collab_js2unityTemporalRefSynopticTask,
									   'referenceVariant' : referenceVariant,
									   'tdrcWithName' : location,
									   'pointInTimeFrom' : timeRangeStart, 
									   'pointInTimeTo' : timeRangeEnd,
									   'dimension' : 'all',
									   'referenceIndicator' : selectedIndicator };

			// create JSON string based on message object's keys and values
			var jsonString = JSON.stringify(jsonDefaultMessage);

			// send string to WebSocket server
			socket.send(jsonString);
		}
	}


	// === VR USER INFORMATION IN NON-IMMERSIVE INTERFACE: TEMPERATURE AND HUMIDITY VIEW ===

	var clusterIDOfVrUserSelectedNode = null;
	var lastVRUserSelectedTimeEvent = null;
	var lastVRUserSelectedTimeRangeStart = null;
	var lastVRUserSelectedTimeRangeEnd = null;

	function VR_updateSelectedLocation(location)
	{	
		if (location == "null")
		{
			// keep track of selected node by VR user
			clusterIDOfVrUserSelectedNode = null;

			// de-select previously selected node by VR user
			d3.select("#vrUserSelectedClusterCircle")
				.attr('id', null);
		}
		else 
		{
			// keep track of selected node by VR user
			clusterIDOfVrUserSelectedNode = location;

			// de-select previously selected node by VR user
			d3.select("#vrUserSelectedClusterCircle")
				.attr('id', null);

			// get all nodes and highlight the one as selected by the VR user
			d3.selectAll('.clustercircle')
				.filter(function(d){
					//return (d.cluster_id == clusterIDOfVrUserSelectedNode);
					return (d.country == clusterIDOfVrUserSelectedNode);
				})
				.attr('id', 'vrUserSelectedClusterCircle');
		}
	}

	function VR_updateSelectedTimeEvent(timeEvent)
	{
		// keep track of VR user selection
		lastVRUserSelectedTimeEvent = timeEvent;

		// only display information if both VR and non-immersed user are at the same location
		if(clusterIDOfVrUserSelectedNode == currentlySelectedClusterID)
		{
			// in temperature view
			//

			// get x coordinates for time event
			var x = templsXAxisScale(timeEvent);

			//var svg = d3.select('#temperatureview').selectAll("svg");
			var svg = d3.select('#temperatureview').selectAll("svg");

			// draw new line
			svg.append("line")
				.attr("id", "VRtemperatureViewSelectedDateLine")
				.attr("x1", function() {
					return x + templsXAxisMargin;
				})
				.attr("y1", templsYAxisMargin)
				.attr("x2", function() {
					return x + templsXAxisMargin;
				})
				.attr("y2", temperatureLineChartHeight-templsYAxisMargin);


			// in humidity view
			//

			// get x coordinates for time event
			x = humlsXAxisScale(timeEvent);

			//var svg = d3.select('#temperatureview').selectAll("svg");
			svg = d3.select('#humidityview').selectAll("svg");

			// draw new line
			svg.append("line")
				.attr("id", "VRhumidityViewSelectedDateLine")
				.attr("x1", function() {
					return x + humlsXAxisMargin;
				})
				.attr("y1", humlsYAxisMargin)
				.attr("x2", function() {
					return x + humlsXAxisMargin;
				})
				.attr("y2", humidityLineChartHeight-humlsYAxisMargin);
		}	
	}

	function VR_updateSelectedTimeRange(timeRangeStart, timeRangeEnd)
	{
		// determine whether or not to reset
		if (timeRangeStart == "null" || timeRangeEnd == "null")
		{
			lastVRUserSelectedTimeRangeStart = null;
			lastVRUserSelectedTimeRangeEnd = null;
			VR_removeTimeRangeInformation();
		}
		else
		{
			// keep track of VR user selection
			lastVRUserSelectedTimeRangeStart = timeRangeStart;
			lastVRUserSelectedTimeRangeEnd = timeRangeEnd;

			// only display information if both VR and non-immersed user are at the same location
			if(clusterIDOfVrUserSelectedNode == currentlySelectedClusterID)
			{
				// in temperature view
				//

				// get x coordinates for time event
				var xs = templsXAxisScale(timeRangeStart);
				var xe = templsXAxisScale(timeRangeEnd);
				var xWidth = xe-xs;

				VR_updateSelectedTimeEvent(timeRangeStart);

				//var svg = d3.select('#temperatureview').selectAll("svg");
				var svg = d3.select('#temperatureview').selectAll("svg");

				svg.append('rect')
				  .attr("id", "VRtemperatureViewSelectedRangeRect")
				  .attr('x', xs + templsXAxisMargin)
				  .attr('y', templsYAxisMargin)
				  .attr('width', xWidth)
				  .attr('height', temperatureLineChartHeight-templsYAxisMargin*2);

				// draw new start line
				svg.append("line")
					.attr("id", "VRtemperatureViewSelectedRangeStartDateLine")
					.attr("x1", function() {
						return xs + templsXAxisMargin;
					})
					.attr("y1", templsYAxisMargin)
					.attr("x2", function() {
						return xs + templsXAxisMargin;
					})
					.attr("y2", temperatureLineChartHeight-templsYAxisMargin);

				// draw new end line
				svg.append("line")
					.attr("id", "VRtemperatureViewSelectedRangeEndDateLine")
					.attr("x1", function() {
						return xe + templsXAxisMargin;
					})
					.attr("y1", templsYAxisMargin)
					.attr("x2", function() {
						return xe + templsXAxisMargin;
					})
					.attr("y2", temperatureLineChartHeight-templsYAxisMargin);


				// in humidity view
				//

				// get x coordinates for time event
				xs = humlsXAxisScale(timeRangeStart);
				xe = humlsXAxisScale(timeRangeEnd);
				xWidth = xe-xs;

				//VR_updateSelectedTimeEvent(timeRangeStart);

				//var svg = d3.select('#temperatureview').selectAll("svg");
				var svg = d3.select('#humidityview').selectAll("svg");

				svg.append('rect')
				  .attr("id", "VRhumidityViewSelectedRangeRect")
				  .attr('x', xs + humlsXAxisMargin)
				  .attr('y', humlsYAxisMargin)
				  .attr('width', xWidth)
				  .attr('height', humidityLineChartHeight-humlsYAxisMargin*2);

				// draw new start line
				svg.append("line")
					.attr("id", "VRhumidityViewSelectedRangeStartDateLine")
					.attr("x1", function() {
						return xs + humlsXAxisMargin;
					})
					.attr("y1", humlsYAxisMargin)
					.attr("x2", function() {
						return xs + humlsXAxisMargin;
					})
					.attr("y2", humidityLineChartHeight-humlsYAxisMargin);

				// draw new end line
				svg.append("line")
					.attr("id", "VRhumidityViewSelectedRangeEndDateLine")
					.attr("x1", function() {
						return xe + humlsXAxisMargin;
					})
					.attr("y1", humlsYAxisMargin)
					.attr("x2", function() {
						return xe + humlsXAxisMargin;
					})
					.attr("y2", humidityLineChartHeight-humlsYAxisMargin);
			}
		}
	}

	/*
	function VR_removeAllSelectedTimeInformation()
	{
		// in temperature view
		var svg = d3.select('#temperatureview').selectAll("svg");
		svg.selectAll("#VRtemperatureViewSelectedDateLine").remove();
		svg.selectAll("#VRtemperatureViewSelectedRangeRect").remove();
		svg.selectAll("#VRtemperatureViewSelectedRangeStartDateLine").remove();
		svg.selectAll("#VRtemperatureViewSelectedRangeEndDateLine").remove();

		// in humidity view
		svg = d3.select('#humidityview').selectAll("svg");
		svg.selectAll("#VRhumidityViewSelectedDateLine").remove();
		svg.selectAll("#VRhumidityViewSelectedRangeRect").remove();
		svg.selectAll("#VRhumidityViewSelectedRangeStartDateLine").remove();
		svg.selectAll("#VRhumidityViewSelectedRangeEndDateLine").remove();
	}
	*/

	function VR_removeTimeEventInformation()
	{
		// in temperature view
		var svg = d3.select('#temperatureview').selectAll("svg");
		svg.selectAll("#VRtemperatureViewSelectedDateLine").remove();

		// in humidity view
		svg = d3.select('#humidityview').selectAll("svg");
		svg.selectAll("#VRhumidityViewSelectedDateLine").remove();
	}

	function VR_removeTimeRangeInformation()
	{
		// in temperature view
		var svg = d3.select('#temperatureview').selectAll("svg");
		svg.selectAll("#VRtemperatureViewSelectedRangeRect").remove();
		svg.selectAll("#VRtemperatureViewSelectedRangeStartDateLine").remove();
		svg.selectAll("#VRtemperatureViewSelectedRangeEndDateLine").remove();

		// in humidity view
		svg = d3.select('#humidityview').selectAll("svg");
		svg.selectAll("#VRhumidityViewSelectedRangeRect").remove();
		svg.selectAll("#VRhumidityViewSelectedRangeStartDateLine").remove();
		svg.selectAll("#VRhumidityViewSelectedRangeEndDateLine").remove();
	}



	// TODO: update websocket implementation with https://github.com/nicoversity/unity_wss_js
	//var shouldConnectToWebSocketServer = false;		// default setting: do not connnect to websocket server
	/*
	// === WEBSOCKET MESSAGE API
	// incoming (Unity3D -> WebSocker server -> WebClient)
	var ODXVRUserTransformUpdate 	 = 'odxvr_user_transform_update';
	var ODXVRUserNodeSelectionUpdate = 'odxvr_user_node_selection_update';
	var ODXVRUserTimeSelectionUpdate = 'odxvr_user_time_selection_update';

	// outgoing (WebClient -> WebSocketServer -> Unity3D)
	var WEBUserNodeSelectionUpdate = 'web_user_node_selection_update';
	var WEBUserTimeSelectionUpdate = 'web_user_time_selection_update';
	// ==========
	


	// === NETWORK IMPLEMENTATION
	//

	var socket;										// global socket object, handling the connection to the websocket server
	var shouldConnectToWebSocketServer = false;		// default setting: do not connnect to websocket server

	// decide whether the web app should connect to the websocket server or not via url argument
	// standard (no websocket server connection): 	[ https://vrxar.lnu.se/apps/nts-lang-explore/ ]
	// with websocket server connection: 			[ https://vrxar.lnu.se/apps/nts-lang-explore/?wssconnect=true ]
	
	var appURLString = window.location.href;						// grab url that was used to open this web app
	var appURL = new URL(appURLString);								// create URL object
	var wssConnect = appURL.searchParams.get("wssconnect");			// extract url argument "wssconnect"
	if(wssConnect == "true") shouldConnectToWebSocketServer = true;	// set connect to websocket server flag if url argument was set accordingly

	if(shouldConnectToWebSocketServer)
	{
		// create WebSocket connection to server (using socket.io-client)
		socket = io('wss://vrxar.lnu.se:4247/');


		// == DEBUG ==
		// send
		socket.emit('message', 'Hej VRxAR Labs WebSocket server, this is the web client.');
		
		//socket.emit('biip');

		// retrieve
		//socket.on('buup', function(message) {
        //        console.log('websocket event received: buup');
        //        console.log(message);
        //        console.log(message.hello);
        //    });
		
		// == END DEBUG ==


		// == Event listeners (incoming) ==

		// VR user transform update
		socket.on(ODXVRUserTransformUpdate, function(message) {
			//console.log('websocket event received: odxvr_user_transform_update');
			//console.log(message);

			// update the VR user node
			updateVRUserNode(message);
		});

		// VR user node selection update
		socket.on(ODXVRUserNodeSelectionUpdate, function(message) {
			//console.log('websocket event received: ' + ODXVRUserNodeSelectionUpdate);
			//console.log(message);

			// keep track of selected node by VR user
			clusterIDOfVrUserSelectedNode = message.selectedNodeID;

			// update the node that is currently selected by the VR user
			highlightNodeSelectedByVRUser();
		});

		// VR user time selection update
		socket.on(ODXVRUserTimeSelectionUpdate, function(message) {
			//console.log('websocket event received: ' + ODXVRUserTimeSelectionUpdate);
			//console.log(message);

			// update date label to present in time view and load the data
	  		vrUserSelectedTimeDateLabel = message.selectedTime;

	  		// update date label in Time View according to selected date
	  		var labelPos;
	  		if(message.interval == "weekly")
	  		{
	  			labelPos= [ xAxisScale(vrUserSelectedTimeDateLabel), 0 ];
	  		}
	  		else if (message.interval == "daily")
	  		{
	  			labelPos= [ xAxisScale(new Date(vrUserSelectedTimeDateLabel)), 0 ];
	  		}
	  		vrUserSelectedTimeDateLabelPosition = labelPos;

	  		// vr user selection automatically changes time selection in web client
	  		if(shouldVRUserTimeSelectionChangeWEBTimeSelection)
	  		{
	  			//handleTimeViewDateSelection(streamGraphSVG, labelPos, currentlySelectedTimeDateLabel);
	  			handleTimeViewDateSelection(streamGraphSVG, labelPos, vrUserSelectedTimeDateLabel);

	 			// update Map View
				updateMapViewForDate(vrUserSelectedTimeDateLabel);
	  		}
	  		// vr user selection shows only time indicator in Time View
	  		else
	  		{
	  			// update vr user selected time indicator
	 			handleTimeViewDateSelectionByVRUser(streamGraphSVG, labelPos, vrUserSelectedTimeDateLabel);
	  		}
		});
	}

	var vrUserSelectedTimeDateLabel;
	var vrUserSelectedTimeDateLabelPosition;

	// == Socket messages (outgoing) ==
	// Note: All function calls are tagged as 'NETWORKING' wherever applied (for better findability)

	// web user selected a new node in the Map View
	function socketMessageWEBUserNodeSelectionUpdate(nodeID)
	{
		// prepare JSON message that is going to be sent to the websocket server
		var messageJSON = { 'selectedNodeID' : nodeID };

		// send message
		socket.emit(WEBUserNodeSelectionUpdate, messageJSON);
	}

	// web user selected a new time in the Time View
	function socketMessageWEBUserTimeSelectionUpdate(time)
	{
		// prepare JSON message that is going to be sent to the websocket server
		var messageJSON = { 'selectedTime' : time,
							'year' : time.substring(0, 4),
							'month' : time.substring(5, 7),
							'day' : time.substring(8, 10)
						  };

		// send message
		socket.emit(WEBUserTimeSelectionUpdate, messageJSON);
	}
	*/


	// === NETWORKING FEATURES 
	//

	// helper values of different attributes for components representing the VR user
	var ODXVRUserRotLineLength 		= 42;
	var ODXVRUserFovLenth 	   		= 40;
	var ODXVRUserFovDegrees    		= 96;
	var ODXVRUserNodeColor	   		= '#33a02c';
	var ODXVRUserNodeFovColor  		= '#b2df8a' + '80';	// hex code + 80 (80 -> 50% transparency)
	//var ODXVRUserNodeSelectionColor	= '#cc4c02';

	// helper values to determine which components of the VR user representation should be drawn
	var shouldDrawODXVRUserRotationLine 				= true;
	var shouldDrawODXVRUserFovArc 						= true;
	//var shouldVRUserTimeSelectionChangeWEBTimeSelection = false;

	// function to represent the VR user visually as a node in the Map View
	function drawVRUserNode()
	{
		// create a group inside the svg element of the Map View
		var vrUserGroup = d3.select('#mapview').select('svg')
							.append('g')
							.attr('id', 'vrUser');

		// select VR user element
		var vrUserNode = vrUserGroup.selectAll('vrUser');

		// initial hard-coded VR user position
		var vrUserPos = [18.000, 62.000];
	    var vrUser = [vrUserPos];

	    // initialize VR user as 'circle' element and set its start up attributes accordingly
	    vrUserNode.data(vrUser).enter()
			.append('circle')
			.attr('cx', function(d, i) { return projection(d)[0]; })
			.attr('cy', function(d, i) { return projection(d)[1]; })
			.attr('r', '6px')
			.attr('fill', ODXVRUserNodeColor)
			.attr('class', 'vrusercircle')
			.attr('id', 'ODXVR_user_pos_circle');

		// initialize a 'line' element representing the VR user's rotation by adding it to the 'group' element representing the whole VR user 
		if(shouldDrawODXVRUserRotationLine)
		{
			vrUserGroup.append('line')
				.attr('stroke', 'black')
				.attr('id', 'ODXVR_user_rot_line');
		}

		// initialize a 'path' element representing the VR user's field of view (FOV) by adding it to the 'group' element representing the whole VR user 
		if(shouldDrawODXVRUserFovArc)
		{
			vrUserGroup.append('path')
				.attr('fill', ODXVRUserNodeFovColor)
				.attr('id', 'ODXVR_user_fov_path')
				.attr('pointer-events', 'none');
		}
	}

	// function to return the transform attribute value for rotating the line representing the VR user's rotation
	function getTransformStringForVRUserLineRotation(vrUser, angle)
	{
		// synchronize angle rotation between Unity3D and D3.js ( D3.js angle = Unity3D euler angle - 180 degrees)
		angle = angle - 180;

		// construct return value (for transform attribute)
		return 'rotate(' + angle + ',' + vrUser.attr('cx') + ',' + vrUser.attr('cy') + ')';
		
		// return value =
		// 'rotate(angle, x, y)'


		/* OLD implementation using manual translation
			// get numerical position values
			var x = vrUser.attr('cx');
			var y = vrUser.attr('cy');
			x = +x;
			y = +y;

			return 'translate(' + x + ',' + y + ') ' +
				   'rotate(' + angle + ') ' +
				   'translate(' + (-x) + ',' + (-y) + ')';

			// return value =
			// 'translate(x, y) rotate(angle) translate(-x, -y)')
		*/
	}

	// function to update the visual representation of the VR user node in the Map View
	//function updateVRUserNode(transform)
	function updateVRUserNode(posX, posZ, rotY)
	{
		// select 'circle' element representing VR user by using its ID
		var vrUserPosCircle = d3.select('#ODXVR_user_pos_circle');

		// update position, accounting for the projection accordingly
		vrUserPosCircle.attr('cx', function() { return projection([posX, posZ])[0]; })
			  		   .attr('cy', function() { return projection([posX, posZ])[1]; });

		// cache position attributes
		var x = vrUserPosCircle.attr('cx');		// grab position attributes (returns a string)
		var y = vrUserPosCircle.attr('cy');
		x = +x;									// convert string attribute values to numerical (float/int)
		y = +y;

		if(shouldDrawODXVRUserRotationLine)
		{
			// select 'line' element representing the VR user's rotation
			var vrUserRotLine = d3.select('#ODXVR_user_rot_line');

			// update position
			vrUserRotLine.attr('x1', x)
						 .attr('y1', y)
						 .attr('x2', x)
						 .attr('y2', y + ODXVRUserRotLineLength);

			// update rotation
			vrUserRotLine.attr('transform', getTransformStringForVRUserLineRotation(vrUserPosCircle, rotY));
		}

		if(shouldDrawODXVRUserFovArc)
		{
			// D3.js Shape Arc documentation: [ https://github.com/d3/d3-shape#arcs ]

			// select 'path' element representing the VR user's field of view
			var vrUserFovArc = d3.select('#ODXVR_user_fov_path');

			// create ARC 		
			var arc = d3.arc()
			    .innerRadius(0)
			    .outerRadius(ODXVRUserFovLenth)
			    .startAngle(0 * (Math.PI/180) ) // converting from degrees to radians
			    .endAngle(ODXVRUserFovDegrees * (Math.PI/180)); // converting from degrees to radians

			// set position and rotation of arc
			var arcTransform = 'translate(' + x + ',' + y + ')' +
								'rotate(' + (rotY - ODXVRUserFovDegrees * 0.5) + ')';

			// update arc using the new attributes
			vrUserFovArc.attr("d", arc)
			    		.attr("transform", arcTransform);
		}
	}

/*
	// function to highlight the cluster (node) as currently selected by the VR user
	var clusterIDOfVrUserSelectedNode;
	function highlightNodeSelectedByVRUser()
	{
		// de-select previously selected node by VR user
		d3.select("#vrUserSelectedClusterCircle")
			.attr('id', null);

		// get all nodes and highlight the one as selected by the VR user
		d3.selectAll('.clustercircle')
			.filter(function(d){
				return (d.cluster_id == clusterIDOfVrUserSelectedNode);
			})
			.attr('id', 'vrUserSelectedClusterCircle');
	}
*/

	// function to update and display the time the VR user is currently browsing as dashed line and text in the Time View
	function handleTimeViewDateSelectionByVRUser(svg, labelPos, dateLabel)
	{
		// update UI elements in time view
		//

		// remove previous line
		svg.selectAll("#VRUserTimeViewSelectedDateLine").remove();

		// draw new line
		svg.append("line")
			.attr("id", "VRUserTimeViewSelectedDateLine")
			.attr("x1", function() {
				return labelPos[0];
			})
			.attr("y1", 10)
			.attr("x2", function() {
				return labelPos[0];
			})
			.attr("y2", streamGraphHeight-sgYAxisPadding)
			.attr("stroke", ODXVRUserNodeColor)

		// remove previous date text label
		svg.selectAll("#VRUserTimeViewSelectedDateText").remove();

		// display date text label
		svg.append("text")
			.attr("id", "VRUserTimeViewSelectedDateText")
			.attr("x", function() {
				var xPos = labelPos[0] + 46;						// + 46 to position slightly to the right of the current mouse position
				if(xPos > streamGraphWidth - 150) xPos = xPos - 70;	// border handling: when too far right, swap to left
				return xPos;
			})
          	.attr("y", function() {
          		return 14;			// position at static height below x-axis
          	})
         	.text( function () {
         		return dateLabel + ' (VR)';
         	})
         	.attr("fill", ODXVRUserNodeColor);
	}


	// === VISUALIZATION IMPLEMENTATION
	//

	// === GLOBAL VARIABLES ACROSS VIEWS ===

	var languageColors = d3.scaleOrdinal()
		.domain([0, 1, 2, 3, 4, 5, 6, 7])
	    .range(["#ffd92f",	// Swedish: 	ffd92f
	    	"#fc8d62",		// Danish: 		fc8d62
	    	"#8da0cb",		// Norwegian: 	8da0cb
	    	"#a6d854",		// Finnish: 	a6d854
	    	"#b3b3b3",		// Icelandic: 	b3b3b3
	    	"#e78ac3",		// English: 	e78ac3
	    	"#e5c494",		// Other: 		e5c494
	    	"#66c2a5"]);	// Unknown: 	66c2a5


	// === MAP VIEW ===

	// === Note ===
	// overall adapted from example demonstrated by Robert Jesionek via 
	// 1) [ https://github.com/jesion/d3js-flight-connections-map ]
	// 2) [ http://d3js.robertjesionek.com/flight-connections-map/ ]
       
	// helper values
	var shouldHighlightCapitalClusters = true;		// indicates whether clusters containing capitals should be given a special visual cue

    // overall map drawing
    //  
    var mapWidth  = 850;				// orignal nordic based on nts-lang-explore: 850
    var mapHeight = 600;				// orignal nordic based on nts-lang-explore: 600
    var mapCenter = [10, 71.7];			// orignal nordic based on nts-lang-explore: [4, 71.7]
    var mapScale  = 500;				// orignal nordic based on nts-lang-explore: 830

    // COLLABORATION-STUDY-IMAC-SETUP
    mapWidth  = 1100;				// orignal nordic based on nts-lang-explore: 850
    mapHeight = 1100;				// orignal nordic based on nts-lang-explore: 600
    mapCenter = [10, 71.7];			// orignal nordic based on nts-lang-explore: [4, 71.7]
    mapScale  = 850;				// orignal nordic based on nts-lang-explore: 830


	var projection = d3.geoMercator()
						.scale(mapScale)
						.translate([mapWidth / 2, 0]).center(mapCenter);

 	//var stockholmGeo  = [18.070, 59.330];
 	//console.log(projection([18.070, 59.330]))

    var path = d3.geoPath().projection(projection);

    var mapSVG = d3.select('#mapview')
    				.append('svg')
      				.attr('height', mapHeight)
      				.attr('width', mapWidth)
      				.style('background', '#4292c6');

    var countries = mapSVG.append("g")
    						.attr('class', 'mapViewCountries');

    var clusterGroup = mapSVG.append("g")
    							.attr('id', 'mapViewClusters');

	//d3.json("data/geodata_nordic_countries_pretty.json").then(function(data){		// load only Nordic countries
	//d3.json("data/geodata_europe_pretty.json").then(function(data){					// load Europe countries
	d3.json("data/map/world_countries_25p.json").then(function(data){					// load world countries
    
      //console.log("map", data);

	  // world countries data download (geosjon format): https://datahub.io/core/geo-countries#data
	  // conversion of geojson to topojson (with 25% of points retained): http://shancarter.github.io/distillery/	

      countries.selectAll('.country')
      	//.data(topojson.feature(data, data.objects.europe).features)		// --> data/geodata_europe_pretty.json
      	.data(topojson.feature(data, data.objects.countries).features)		// --> data/map/world_countries_25p.json
      	.enter()
      	.append('path')
      	.attr('class', function(d,) {
      		//console.log(d);
      		return 'nordiccountry';

      		// classify countries drifferenly depending whether they are a Nordic country or not
      		//if( d.properties.NAME == "Sweden" ||
      		//	d.properties.NAME == "Denmark" ||
      		//	d.properties.NAME == "Norway" || 
      		//	d.properties.NAME == "Finland" || 
      		//	d.properties.NAME == "Iceland")
      		//	return 'nordiccountry';
      		//else
      		//	return 'country';
      	})
      	.attr('d', path);
      	return;
    });


    // drawing clusters as circles
    // 
    var clusters;

    //function updateMapViewForDate(date)
    function updateMapViewWithCentroids()
    {
		// delete previous map data entries
		clusterGroup.selectAll(".mapViewClusterCircles").remove();

		// create current map data entries
	    var clusterCirclesGroup = clusterGroup.append("g")
	    										.attr("class", "mapViewClusterCircles");
		clusters = clusterCirclesGroup.selectAll('cluster');

		/*
		// DEBUG (START) : circle for each capital
	    var stockholmGeo  = [18.070, 59.330];
	    var helsinkiGeo   = [24.940, 60.170];
	    var osloGeo 	  = [10.750, 59.910];
	    var copenhagenGeo = [12.570, 55.680];
	    var reykjavikGeo  = [-21.920, 64.140];
	    
	    var nordicCapitals = [stockholmGeo, helsinkiGeo, osloGeo, copenhagenGeo, reykjavikGeo];

	    clusters.data(nordicCapitals).enter()
			.append('circle')
			.attr('cx', function(d, i) { return projection(d)[0]; })
			.attr('cy', function(d, i) { return projection(d)[1]; })
			.attr('r', '6px')
			.attr('fill', 'darkred')
			.attr('class', 'clustercircle');
		// DEBUG (END)
		*/

		//var clusterFileForCurrentDate = grabClusterFileForDate(date);
		//console.log("fileToLoadForMapView = " + fileToLoad);

		// load csv file: https://github.com/d3/d3-fetch/blob/master/README.md#dsv
		//d3.dsv(",", "data/daily/_nts_generated_clusters_demo_unique.csv").then(function(data) {
		//d3.dsv(",", clusterFileForCurrentDate)
		d3.dsv(",", "data/map/europe_centroids.csv")
			.then(function(data) {
				

				// TODO: place circle for Norway more appropriately

				// DEBUG - check loaded data set
				//console.log(data);
				//console.log(data[0]);
				//console.log(data[0].country);
				//console.log(data[0].x);
				//console.log(data[0].y);

				clusters.data(data).enter()
					//.filter(function(d){	// only draw clusters if tweet data exists
					//	//console.log(d.Total);
					//	return d.Total > 0;
					//})	
					.append('circle')
					.attr('cx', function(d) {
						//console.log(d);
						//console.log(d.cluster_x);
						//console.log(projection(d.cluster_x));
						//console.log(projection(d.cluster_x)[0]);
						//return d.cluster_x;
						return projection([d.x, d.y])[0];
					})
					.attr('cy', function(d) {
						//return projection(d.cluster_y)[1];
						//return d.cluster_y;
						return projection([d.x, d.y])[1];
					})
					.attr('r', '6px')
					.attr('fill', function(d) {

						return '#404040';
						/*
						// DATA_LOADING_SWITCH
						// Note: workaround for a typo within the daily cluster data set ("Finnish" (weekly) was spellec "Finish" (daily))
						if(clusterTimeFrequency == "weekly")
						{
							// color circle based on most frequent language

							var tweetValues = [d.Swedish, d.Danish, d.Norwegian, d.Finnish, d.Icelandic, d.English, d.Other, d.Unknown];
							var max = Math.max(...tweetValues);
							
							//console.log(max + " = for cluster id " + d.cluster_id);

							var clusterColor = "#FFFFFF";
							if(d.Swedish == max ) clusterColor = languageColors(0);
							else if (d.Danish == max ) clusterColor = languageColors(1);
							else if (d.Norwegian == max ) clusterColor = languageColors(2);
							else if (d.Finnish == max ) clusterColor = languageColors(3);
							else if (d.Icelandic == max ) clusterColor = languageColors(4);
							else if (d.English == max ) clusterColor = languageColors(5);
							else if (d.Other == max ) clusterColor = languageColors(6);
							else if (d.Unknown == max ) clusterColor = languageColors(7);

							return clusterColor;
						}
						else if(clusterTimeFrequency == "daily")
						{
							// color circle based on most frequent language

							var tweetValues = [d.Swedish, d.Danish, d.Norwegian, d.Finish, d.Icelandic, d.English, d.Other, d.Unknown];
							var max = Math.max(...tweetValues);
							
							//console.log(max + " = for cluster id " + d.cluster_id);

							var clusterColor = "#FFFFFF";
							if(d.Swedish == max ) clusterColor = languageColors(0);
							else if (d.Danish == max ) clusterColor = languageColors(1);
							else if (d.Norwegian == max ) clusterColor = languageColors(2);
							else if (d.Finish == max ) clusterColor = languageColors(3);
							else if (d.Icelandic == max ) clusterColor = languageColors(4);
							else if (d.English == max ) clusterColor = languageColors(5);
							else if (d.Other == max ) clusterColor = languageColors(6);
							else if (d.Unknown == max ) clusterColor = languageColors(7);

							return clusterColor;
						}
						*/

						/*
						// fill cluster based on country (hardcoded from sorted data structure / input data)
						if(d.cluster_id >= 0 && d.cluster_id <= 18) return 'green';	// denmark
						else if(d.cluster_id >= 19 && d.cluster_id <= 113) return 'yellow';	// sweden
						else if(d.cluster_id >= 114 && d.cluster_id <= 225) return 'red';	// norway
						else if(d.cluster_id >= 226 && d.cluster_id <= 308) return 'blue';	// finland
						else return 'white';
						*/
					})
					.attr('class', function(d, i){
						return 'clustercircle';
						/*
						// check whether clusters containing capitals should be handled differently
						if(shouldHighlightCapitalClusters){
							// check for capital cluster (IDs hardcoded based on data)
							if( d.cluster_id ==   6 ||		// Copenhagen		
								d.cluster_id ==  40 ||		// Stockholm
								d.cluster_id == 118 ||		// Oslo
								d.cluster_id == 233) {		// Helsinki
								// current cluster contains a capital
								return 'clustercirclecapital';
							}
							else {
								// current cluser does not contain a capital
								return 'clustercircle';
							}
						}
						// all clusters are equally treated
						else {
							return 'clustercircle';
						}
						*/
					})
					.attr('id', function(d, i){
						// check if iterated circle is the currently selected one, and set it's ID accordingly
						return (d.country == currentlySelectedClusterID) ? "selectedClusterCircle" : null;
					})
					.on("click", function(d) {

						// update clicked circle (representing the selected cluster)
						d3.select("#selectedClusterCircle").attr("id", null);	// remove highlight (ID attribute) from previus selected one 
						//d3.select(this).attr("id", "selectedClusterCircle");	// add highlight (ID attribute) to newly selected one
						d3.select(this).attr("id", function(d)
						{
							// add highlight (ID attribute) to newly selected one, only if it is not the current VR user's one
							if (d.country != clusterIDOfVrUserSelectedNode) return "selectedClusterCircle";	
							else return "vrUserSelectedClusterCircle";
						});

						// set global variable
						currentlySelectedClusterID = d.country;
						
						// update views
		  				//updateClusterDetailViewForCluster(currentlySelectedClusterID, clusterFileForCurrentDate);
		  				//updateTimeViewForCluster(currentlySelectedClusterID);
		  				//updatePlacesViewForForCluster(currentlySelectedClusterID);
						updateTemperatureViewForCountry(currentlySelectedClusterID);
						updateHumidityViewForCountry(currentlySelectedClusterID);

						// NETWORKING
						networking_js2unity_spatialReferenceSingle(currentlySelectedClusterID);

		  				// NETWORKING
		  				//if(shouldConnectToWebSocketServer)
		  				//	socketMessageWEBUserNodeSelectionUpdate(currentlySelectedClusterID);

		  				// LOGGING
		  				//if(shouldLog)
		  				//	logNumberOfNodeSelections();
					})
					.append("title")
					.text(function(d) {
						//return "Cluster ID: " + d.cluster_id;
						return d.country;
					});

					// update cluster detail view when map data was loaded
					//updateClusterDetailViewForCluster(currentlySelectedClusterID, clusterFileForCurrentDate);

					// NETWORKING
					//if(shouldConnectToWebSocketServer)
    				//	highlightNodeSelectedByVRUser();
			})
			.catch(function(error) {
				// update views according to "no data scenario"
				updateViewsForNoDataAvailable();
    		});
    }


    /*
	// === CLUSTER DETAIL VIEW ===

	// === Note ===
	// overall adapted from example demonstrated by Mike Bostock via 
	// [ https://bl.ocks.org/mbostock/3887193 ]
	// and Michael Hall
	// [ https://bl.ocks.org/mbhall88/22f91dc6c9509b709defde9dc29c63f2 ]

	var donutWidth = 400,
	    donutHeight = 400,
	    donutRadius = Math.min(donutWidth, donutHeight) / 2;

	// setup arc [ https://github.com/d3/d3-shape/blob/master/README.md#arcs ]
	var donutArc = d3.arc()
	    .outerRadius(donutRadius * 0.6)
	    .innerRadius(donutRadius * 0.9)
	    .cornerRadius(6);

	// setup pie function for data handling [ https://github.com/d3/d3-shape/blob/master/README.md#pies ]
	var donutPie = d3.pie()
    	.sort(null)
    	.value(function(d) {
    		return d;
    	});    

	// helper value to get language data for index
	function currentLanguageForIndex(index)
	{
		var langJSON = { 'lang' : '',
						 'tweets': 0,
						 'total' : 0,
						 'percentage' : 0 };

		langJSON.total = currentlySelectedClusterData.Total;

		switch(index)
		{
			case 0:
				langJSON.lang = "Swedish";
				langJSON.tweets = currentlySelectedClusterData.Swedish;
				break;
			case 1:
				langJSON.lang = "Danish";
				langJSON.tweets = currentlySelectedClusterData.Danish;
				break;
			case 2:
				langJSON.lang = "Norwegian";
				langJSON.tweets = currentlySelectedClusterData.Norwegian;
				break;
			case 3:
				langJSON.lang = "Finnish";
				// DATA_LOADING_SWITCH
				if(clusterTimeFrequency == "weekly")
					langJSON.tweets = currentlySelectedClusterData.Finnish;
				else if(clusterTimeFrequency == "daily")
					langJSON.tweets = currentlySelectedClusterData.Finish;
				break;
			case 4:
				langJSON.lang = "Icelandic";
				langJSON.tweets = currentlySelectedClusterData.Icelandic;
				break;
			case 5:
				langJSON.lang = "English";
				langJSON.tweets = currentlySelectedClusterData.English;
				break;
			case 6:
				langJSON.lang = "Other";
				langJSON.tweets = currentlySelectedClusterData.Other;
				break;
			case 7:
				langJSON.lang = "Unknown";
				langJSON.tweets = currentlySelectedClusterData.Unknown;
				break;		
		}

		langJSON.percentage = Math.floor( langJSON.tweets / langJSON.total * 100 ).toFixed(0);

		return langJSON;
	}

	// reference to the cluster ID that is currently being selected
	var currentlySelectedClusterID;

	// reference to the cluster data that has currently being selected using the Map View
	var currentlySelectedClusterData;

	// draw cluster detail view
	function updateClusterDetailViewForCluster(cluster_id, file)
	{
		// update view for "no data scenario"
		if(cluster_id == null && file == null)
		{
			// update cluster ID caption
			d3.select("#clustername")
				.text("No data available for date");

			// update cluster date caption
			d3.select("#clusterdate")
				.text(currentlySelectedTimeDateLabel);

			// remove all existing svg child elements from the div with the entered ID
			d3.select('#clusterdetailview').selectAll("svg").remove();
		}
		// update view for normal scenario
		else
		{
			// update cluster ID caption
			d3.select("#clustername")
				.text("Cluster ID: " + cluster_id);

			// update cluster date caption
			d3.select("#clusterdate")
				.text(currentlySelectedTimeDateLabel);

			// reset cluster no tweet caption
			d3.select("#clusternotweets")
				.text("");

			// remove all existing svg child elements from the div with the entered ID
			d3.select('#clusterdetailview').selectAll("svg").remove();

		    // create SVG element
			var clusterDetailSVG = d3.select('#clusterdetailview')
									 .append('svg')
									 .attr('height', donutWidth)
		  							 .attr('width', donutHeight)
		  							 .append("g")
			    					 .attr("transform", "translate(" + donutWidth / 2 + "," + donutHeight / 2 + ")");

			// load data
			//d3.dsv(",", "data/daily/_nts_2016-11-06_cluster_languages.csv").then(function(data) {
			d3.dsv(",", file).then(function(data) {

				// index of selected cluster
				var selectedClusterIndex = cluster_id - 1;	// cluster IDs start with 1, array indexing starts with 0

				//console.log(data);
				//console.log(data[selectedClusterID]);

				// update currently selected cluster data (global variable)
				currentlySelectedClusterData = data[selectedClusterIndex];

				// normal scenario: total number of tweets > 0
				if(data[selectedClusterIndex].Total > 0)
				{
					// DATA_LOADING_SWITCH
					var selectedClusterData;
					if(clusterTimeFrequency == "weekly")
					{
						// setup data array for selected cluster to be displayed as donut chart
						var selectedClusterData = [ data[selectedClusterIndex].Swedish,
													data[selectedClusterIndex].Danish,
													data[selectedClusterIndex].Norwegian,
													data[selectedClusterIndex].Finnish,
													data[selectedClusterIndex].Icelandic,
													data[selectedClusterIndex].English,
													data[selectedClusterIndex].Other,
													data[selectedClusterIndex].Unknown ];
					}
					else if(clusterTimeFrequency == "daily")
					{
						// setup data array for selected cluster to be displayed as donut chart
						var selectedClusterData = [ data[selectedClusterIndex].Swedish,
													data[selectedClusterIndex].Danish,
													data[selectedClusterIndex].Norwegian,
													data[selectedClusterIndex].Finish,
													data[selectedClusterIndex].Icelandic,
													data[selectedClusterIndex].English,
													data[selectedClusterIndex].Other,
													data[selectedClusterIndex].Unknown ];
					}
					
					//console.log(selectedClusterData);

					// create arc with data
					var donutCluster = clusterDetailSVG.selectAll(".arc")
				    									.data(donutPie(selectedClusterData))
				    									.enter()
				    									.append("g")
				      									.attr("class", "arc");

				    // create paths in arc based on data
					donutCluster.append("path")
				    	.attr("d", donutArc)
				      	.style("fill", function(d, i) {
				      		return languageColors(i);
				      	}); 

				    clusterDetailSVG.selectAll('path').call(languageInfo); 
				}
				// data available but no tweets scenario: total number of tweets = 0
				else
				{
					d3.select("#clusternotweets")
						.text("No one tweeted here.");
				}	 
			});
			// update places view for cluster
			updatePlacesViewForForCluster(currentlySelectedClusterID);
		}
	}

	// display language info in the middle of the donut chart as circle
    function languageInfo(selection) {

        // display when mouse enters the slice of the donut chart
        selection.on('mouseenter', function (data) {

        	//console.log(data);

        	var cdvSVG = d3.select('#clusterdetailview').select("svg");

            cdvSVG.append('circle')
            	.attr('class', 'langInfoCircle')
                .attr("transform", "translate(" + donutWidth / 2 + "," + donutHeight / 2 + ")")
                .attr('r', donutRadius * 0.5) // radius of tooltip circle
                //.style('fill', colour(data.data[category])) // colour based on category mouse is over
                .style('fill', languageColors(data.index))
                .style('fill-opacity', 0.35);

            cdvSVG.append('text')
	  			.attr('class', 'langInfoText')
	  			.attr('transform', "translate(" + donutWidth / 2 + "," + donutHeight / 2 + ")")
	      		.attr("dy", "-2.0em")
	      		.text(currentLanguageForIndex(data.index).lang);

	      	cdvSVG.append('text')
	  			.attr('class', 'langInfoText')
	  			.attr('transform', "translate(" + donutWidth / 2 + "," + donutHeight / 2 + ")")
	      		.attr("dy", "0.0em")
	      		.text(function(d) {
	      			return "Tweets: " + currentLanguageForIndex(data.index).tweets + " / "  + currentLanguageForIndex(data.index).total;
	      		});

	      	cdvSVG.append('text')
	  			.attr('class', 'langInfoText')
	  			.attr('transform', "translate(" + donutWidth / 2 + "," + donutHeight / 2 + ")")
	      		.attr("dy", "2.0em")
	      		.text(function(d, i) {
	      			return "Percentage: " + currentLanguageForIndex(data.index).percentage + " %";
	      		});
        });

        // hide when mouse exits the slice of the donut chart
        selection.on('mouseout', function () {
            d3.selectAll('.langInfoCircle').remove();
            d3.selectAll('.langInfoText').remove();
        });
    }
	*/

	// === PLACES VIEW ===

	/*
	function updatePlacesViewForForCluster(cluster_id)
	{
		// update view for "no data scenario"
		if(cluster_id == null)
		{
			// update caption
			d3.select("#placesclusterid")
				.text("Selected Country: none");

			//d3.select("#placesincluster")
			//		.text("");
		}
		// update view for normal scenario
		else
		{
			// update caption
			d3.select("#placesclusterid")
				.text("Selected Country: " + cluster_id);

			// DATA_LOADING_SWITCH
			var placesClusterLookupFilePath;
			if(clusterTimeFrequency == "weekly")
				placesClusterLookupFilePath = "data/weekly/_places_cluster_lookup.csv";
			else if(clusterTimeFrequency == "daily")
				placesClusterLookupFilePath = "data/daily/_places_cluster_lookup.csv";

			// build places string
			d3.dsv(",", placesClusterLookupFilePath).then(function(data) {

				var placesString = "";
				for(var i = 0; i < data.length; i++)
				{
					if(data[i].cluster_id == cluster_id)
					{
						placesString = placesString + data[i].place_name + ", ";
					}
				}

				// cut off last ", "
				placesString = placesString.substring(0, placesString.length-2);

				// update places
				d3.select("#placesincluster")
					.text(placesString);
			});			
		}
	}
	*/

	/*
	// === TIME VIEW ===

	// === Note ===
	// overall adapted from example demonstrated by f94f via 
	// [ https://bl.ocks.org/f94f/5554bf0a6874a64f46deacf3448ee5c8/8cc81693c17377a77b0741252be02fc69409da9a ]
	// and Jane Dilkes via 
	// [ https://bl.ocks.org/jdilkes/f9d99adee07430072f96ebaa1056dc39 ]
	// and Harry Stevens via
	// [ https://bl.ocks.org/HarryStevens/c893c7b441298b36f4568bc09df71a1e ]

	var streamGraphWidth = 1650,
		streamGraphHeight = 500,
		sgXAxisPadding = 50,
		sgYAxisPadding = 20;

	var streamGraphSVG;	// reference to stream graph svg element

	var xAxisScale; 		// reference to stream graph x-axis scale [ https://github.com/d3/d3-scale#time-scales ] 
	var xAxisScaleInvert;	// create helper scale since ordinal scale do not feature an invert() function (used for weekly data set)

	var currentlySelectedTimeMousePos;		// reference to last clicked mouse position in time view
	var currentlySelectedTimeDateLabel;		// reference to currently selected date according to time view

	var tvMouseXOffset = -4;		// helper function to translate time view's date slider by a few pixels (otherwise the mouse would select the slider svg element all the time)

	// helper functions to determine min / max layer in a series of data points
	// via [ https://bl.ocks.org/mbostock/4060954 ]
	function stackMax(layer) {
	  return d3.max(layer, function(d) {
	  	return d[1];
	  });
	}

	function stackMin(layer) {
	  return d3.min(layer, function(d) {
	  	return d[0];
	  });
	}

	function updateTimeViewForCluster(cluster_id)
	{
		// remove all existing svg child elements from the div with the entered ID
		d3.select('#timeview').selectAll("svg").remove();

		// build cluster file path to load correct data file from server
		var clusterFileSuffix = "" + cluster_id;
		if(cluster_id < 10) clusterFileSuffix = "00" + cluster_id;
		else if (cluster_id < 100 && cluster_id >= 10) clusterFileSuffix = "0" + cluster_id;

		// DATA_LOADING_SWITCH
		var streamGraphFilePath;
		if(clusterTimeFrequency == "weekly")
			streamGraphFilePath = "data/weekly/streamgraph_demoht18_lang/cluster_" + clusterFileSuffix + ".csv";
		else if(clusterTimeFrequency == "daily")
			streamGraphFilePath = "data/daily/streamgraph_demovt18_lang/cluster_" + clusterFileSuffix + ".csv";

		//console.log(streamGraphFilePath);

		// load data file
		d3.dsv(",", streamGraphFilePath).then(function(data) {

			//console.log(data)

			// using the data from the csv file, create a new nest structure
			// key = data entry's date, value = data entry
			var nested_data = d3.nest()
								.key(function(d) {
									return d.date;
								})
								.entries(data);

			// DATA_LOADING_SWITCH
			var langData;
			if(clusterTimeFrequency == "weekly")
			{
				// using the nested data structure, create a map
				// holding an object of type "string" as well as all the language data for that week
				langData = nested_data.map(function(d, i){

				    // create week string object
				    var obj = {
				    	date: d.key
				    }
				    
				    // assign language values
				    d.values.forEach(function(v){
				    	obj[v.lang] = parseInt(v.count);
				    });
				    
				    // return statement
				    return obj;
				});
			}
			else if(clusterTimeFrequency == "daily")
			{
				// using the nested data structure, create a map
				// holding an object of d3.js type "date" as well as all the language data for that date
				langData = nested_data.map(function(d, i){

				    //DEBUG substring
				    //console.log(d.key);
				    //console.log(d.key.substring(0, 4));		// year
				    //console.log(d.key.substring(5, 7));		// month
				    //console.log(d.key.substring(8, 10));	// day
				    //console.log("#####");

					// extract values for date generation from key string
				    var yyyy, mm, dd;
				    yyyy = d.key.substring(0, 4);
				    mm = d.key.substring(5, 7);	
				    dd = d.key.substring(8, 10);

				    // ATTENTION:
				    // month january = 0 (feb = 1, ...) , which means the extracted month needs to be subtracted by 1 when creating the date
				    // year and day can be taking as normal

				    // create date object
				    var obj = {
				    	date: new Date(yyyy, parseInt(mm) - 1, dd)
				    }
				    
				    // assign language values
				    d.values.forEach(function(v){
				    	obj[v.lang] = parseInt(v.count);
				    });
				    
				    // return statement
				    return obj;
				});
			}

			// create stream graph using language data (map)
			createStreamGraph(langData);
		});
	}

	function createStreamGraph(langData) {
		
		// DATA_LOADING_SWITCH
		var stackLangKeys;
		if(clusterTimeFrequency == "weekly")
		{
			stackLangKeys = ["Swedish", "Danish", "Norwegian", "Finnish", "Icelandic", "English", "Other", "Unknown"];
		}
		else if(clusterTimeFrequency = "daily")
		{
			stackLangKeys = ["Swedish", "Danish", "Norwegian", "Finish", "Icelandic", "English", "Other", "Unknown"];
		}

		// create a new stack using the individual language keys		  
		var stack = d3.stack()
		    .keys(stackLangKeys)
		    .order(d3.stackOrderInsideOut)		// larger values on the inside, smaller on the outside (recommended for stream graphs)
		    .offset(d3.stackOffsetWiggle);		// shifts baseline to minimize weighted wiggle of layers (recommended for stream graphs)

		// genetate stack for the entered language data
		var langSeries = stack(langData);

		// DATA_LOADING_SWITCH
		if (clusterTimeFrequency == "weekly")
		{
			// weekly data uses a string object representing the individual weeks (compared to the daily data set using a date object), therefore an ordinal scale (instead of a time scale)

			// create array with the individual weeks representing the scale's domain
			var weeksDomain = new Array();
			for(var i = 0; i < langData.length; i++)
			{
				weeksDomain.push(langData[i].date);
			}

			// create array with the tick values corresponding to the individual weeks representing the scale's range
			var weeksRange = new Array();
			for(var i = 0; i < weeksDomain.length; i++)
			{
				var currentRangeValue = sgXAxisPadding + ( (streamGraphWidth-sgXAxisPadding) / weeksDomain.length * i); // x-axis according to width (considering left and right padding)
				weeksRange.push(currentRangeValue);
			}

			// create scale for x-axis
			xAxisScale = d3.scaleOrdinal()
								.domain(weeksDomain)
								.range(weeksRange);

			// create helper scale since ordinal scale do not feature an invert() function
			// note: this is needed to get the domain value from entering a range value (e.g. get week value from hovered pointer in the time line (range value))
			xAxisScaleInvert = d3.scaleQuantile()
								.domain(weeksRange)
								.range(weeksDomain);
		}
		else if (clusterTimeFrequency == "daily")
		{
			// create scale for x-axis
			xAxisScale = d3.scaleTime()									// linear time scale
						    .domain(d3.extent(langData, function(d){	// domain = values of time scale (d3.extent returns [min, max] of all date values in language array)
						    	return d.date;
						    }))
						    .range([sgXAxisPadding, streamGraphWidth-sgXAxisPadding]);	// draw x-axis according to width (considering left and right padding)
		}

		// setup x-axis according to scale
		var xAxis = d3.axisBottom(xAxisScale);

		// DATA_LOADING_SWITCH
		if(clusterTimeFrequency == "weekly")
		{
			// create ticks of ordinal (weekly) x-axis
			// label only every 5th week item
			var xAxisTicksWeekly = xAxisScale.domain().filter(function(d,i){
													return !(i%5);
												});
			// apply filtered tick values to x-axis
			xAxis.tickValues(xAxisTicksWeekly);
		}

		// create scale for y-axis
		var yAxisScale = d3.scaleLinear()						// linear scale
						    .domain([d3.min(langSeries, stackMin), d3.max(langSeries, stackMax)])	// domain = values for linear scale (min and max for langSeries data)
						    .range([streamGraphHeight, sgYAxisPadding*4]);		// draw y-axis according to streamgraph height

		// create new area for languages (area = defined by two bouding lines)
		var langArea = d3.area()
		    .x(function(d) {
		    	// x0 = date along the time axis; x1 = null
		    	return xAxisScale(d.data.date);
		    })
		    .y0(function(d) {
		    	// y0 = baseline (retrieved from setup y-axis based on language series data)
		    	return yAxisScale(d[0]);
		    })
		    .y1(function(d) {
		    	// y1 = topline (retrieved from setup y-axis based on language series data)
		    	return yAxisScale(d[1]);
		    })
		    .curve(d3.curveBasis);		// create curve based on setup points for x and y; cubic basis line

		// create variable to stream graph svg element in view and set it up acccordingly
		streamGraphSVG = d3.select('#timeview')
							.append('svg')
							.attr('width', streamGraphWidth)
							.attr('height', streamGraphHeight);

		// draw stream graph
		streamGraphSVG.selectAll("path")
		    .data(langSeries)
		    .enter()
		    	.append("path")
		    	.attr("class", "languageTimePath")
		    	.attr("d", langArea)
		    	.style("fill", function(d, i) {
		    		return languageColors(i);
		    	})
			    .on('mouseover', function(d, i) {
			    	// add stroke to path
			    	d3.select(this).style('stroke', "#5e5e5e")
			    					.style('stroke-width', "1px");
			    })
			    .on('mousemove', function(d, i){
			    	// show label tool tip in ui with value of currently hovered language path
			    	handleMouseMoveInStreamGraphPathUI(streamGraphSVG, langData, i, xAxisScale, [ d3.mouse(this)[0] + tvMouseXOffset, d3.mouse(this)[1] ]);

			    })
			    .on('mouseout', function(d, i) {
			    	// remove stroke from path
			    	d3.select(this).style('stroke', null)
			    					.style('stroke-width', null);

			    	// remove label tool tip
			    	streamGraphSVG.selectAll("#timeViewMouseOverPathText").remove();

			    });
		
		// draw x-axis
		var xAxisGroup = streamGraphSVG.append("g")
										.attr("transform", "translate(0," + (sgYAxisPadding) + ")")
										.call(xAxis);

		// update time view date picker according to last selected date
	 	handleTimeViewDateSelection(streamGraphSVG, currentlySelectedTimeMousePos, currentlySelectedTimeDateLabel);

	 	// update vr user selected time indicator
	 	if(shouldConnectToWebSocketServer == true &&
	 	   shouldVRUserTimeSelectionChangeWEBTimeSelection == false)
	 	{
	 		if(vrUserSelectedTimeDateLabel != null)
	 		handleTimeViewDateSelectionByVRUser(streamGraphSVG, vrUserSelectedTimeDateLabelPosition, vrUserSelectedTimeDateLabel);
	 	}

		// Mouse interaction with TimeView
		// overall adapted from example demonstrated by Paul Sherman via
		// [ https://www.pshrmn.com/tutorials/d3/mouse/ ]
		// and by Mike Bostock via
		// [ https://bl.ocks.org/mbostock/3902569 ]
		// Mouse events tutorial via [ https://www.stator-afm.com/tutorial/d3-js-mouse-events/ ]

		
		// add listener for mouse movement in stream graph svg: date preview
		streamGraphSVG.on('mousemove', function(){
			
			// get coordinates from mouse in stream graph svg
			//var mousePosition = d3.mouse(this);
			var mousePosition = [ d3.mouse(this)[0] + tvMouseXOffset, d3.mouse(this)[1] ];

			// grab x position and apply border handling based on stream graph x-axis scale
			if(mousePosition[0] < sgXAxisPadding == false && mousePosition[0] > streamGraphWidth-sgXAxisPadding == false)
			{
				// DATA_LOADING_SWITCH
				var domainX;
				if(clusterTimeFrequency == "weekly")
				{
					// invert the scale to get the domain value
					// for ordinal scale, helper axis is used
		  			domainX = xAxisScaleInvert(mousePosition[0]);
				}
				else if(clusterTimeFrequency == "daily")
				{
					// invert the scale to get the domain value
					// domainX variable = JavaScript Date object according to setup x-Axis
		  			domainX = xAxisScale.invert(mousePosition[0]);
				}

		  		// update view according to mouse movement
		 		updateTimeViewMouseOver(streamGraphSVG, mousePosition, createDateLabelStringFromDate(domainX));
			}

		});

		// add listener for mouse leave in stream graph svg: remove date preview
		streamGraphSVG.on('mouseleave', function(){

			// remove preview line from svg
			removeTimeViewMouseOver(streamGraphSVG);
		});

		// add listener for mouse click in stream graph svg: date selection
		streamGraphSVG.on('click', function(){

			// get coordinates from mouse in stream graph svg
			//currentlySelectedTimeMousePos = d3.mouse(this);
			currentlySelectedTimeMousePos = [ d3.mouse(this)[0] + tvMouseXOffset, d3.mouse(this)[1] ];
			//console.log(currentlySelectedTimeMousePos);

			// grab x position and apply border handling based on stream graph x-axis scale
			if(currentlySelectedTimeMousePos[0] < sgXAxisPadding == false &&
			   currentlySelectedTimeMousePos[0] > streamGraphWidth-sgXAxisPadding == false)
			{
				// DATA_LOADING_SWITCH
				var domainX;
				if(clusterTimeFrequency == "weekly")
				{
					// invert the scale to get the domain value
					// for ordinal scale, helper axis is used
		  			domainX = xAxisScaleInvert(currentlySelectedTimeMousePos[0]);
				}
				else if(clusterTimeFrequency == "daily")
				{
					// invert the scale to get the domain value
					// domainX variable = JavaScript Date object according to setup x-Axis
	  				domainX = xAxisScale.invert(currentlySelectedTimeMousePos[0]);
				}

	  			// create date label to present in time view and load the data
	  			currentlySelectedTimeDateLabel = createDateLabelStringFromDate(domainX);

	  			// update view according to mouse position
	 			handleTimeViewDateSelection(streamGraphSVG, currentlySelectedTimeMousePos, currentlySelectedTimeDateLabel);

	 			// update map view
				updateMapViewForDate(currentlySelectedTimeDateLabel);

				// NETWORKING
				if(shouldConnectToWebSocketServer)
					socketMessageWEBUserTimeSelectionUpdate(currentlySelectedTimeDateLabel);

				// LOGGING
				if(shouldLog)
					logNumberOfTimeSelections();
			}
		});
		
	}

	function handleMouseMoveInStreamGraphPathUI(svg, langData, i, xAxisScale, mousePos)
	{
		// DATA_LOADING_SWITCH
		var result;
		if(clusterTimeFrequency == "weekly")
		{
			// language and value for currently hovered path at the specific date along the x-axis time scale
			//

			// get week string based on current mouse position
	    	var domainX = xAxisScaleInvert(mousePos[0]);

			// find object with specific week string in language data
	    	var result = langData.filter(function(obj) {
					return obj.date === domainX;
			});
		}
		else if(clusterTimeFrequency == "daily")
		{
			// language and value for currently hovered path at the specific date along the x-axis time scale
			//

			// create date object based on current mouse position
	    	var domainX = xAxisScale.invert(mousePos[0]);
	    	var dateObj = new Date(createDateLabelStringFromDate(domainX));

			// find object with specific date in language data || array version
			//for(var i = 0; i < langData.length; i++)
			//{
			//	if(langData[i].date.getFullYear() === dateObj.getFullYear() &&
			//		langData[i].date.getMonth() === dateObj.getMonth() &&
			//		langData[i].date.getDate() === dateObj.getDate())
			//		console.log(langData[i]);
			//}

			// find object with specific date in language data || array.filter() version
	    	var result = langData.filter(function(obj) {
					return obj.date.getFullYear() === dateObj.getFullYear() &&
						obj.date.getMonth() === dateObj.getMonth() &&
						obj.date.getDate() === dateObj.getDate();
			});
	    	//console.log(result[0])
	    }

    	var labelText = "";

    	// check if there is a new label to be built
    	if(result.length > 0)
    	{
			switch(i)
			{
				case 0:
					labelText = "Swedish: " + result[0].Swedish;
					break;
				case 1:
					labelText = "Danish: " + result[0].Danish;
					break;
				case 2:
					labelText = "Norwegian: " + result[0].Norwegian;
					break;
				case 3:
					// DATA_LOADING_SWITCH
					if(clusterTimeFrequency == "weekly")
						labelText = "Finnish: " + result[0].Finnish;
					else if(clusterTimeFrequency == "daily")
						labelText = "Finnish: " + result[0].Finish;
					break;
				case 4:
					labelText = "Icelandic: " + result[0].Icelandic;
					break;
				case 5:
					labelText = "English: " + result[0].English;
					break;
				case 6:
					labelText = "Other: " + result[0].Other;
					break;
				case 7:
					labelText = "Unknown: " + result[0].Unknown;
					break;		
			}
		}
		else
		{
			labelText = "No available data.";
		}

		// remove label text
    	svg.selectAll("#timeViewMouseOverPathText").remove();

		// update UI label
		svg.append("text")
			.attr("id", "timeViewMouseOverPathText")
			.attr("x", function() {
				var xPos = mousePos[0] + 6;							// + 6 to position slightly to the right of the current mouse position
				if(xPos > streamGraphWidth - 150) xPos = xPos - 76;	// border handling: when too far right, swap to left
				return xPos;		
			})
          	.attr("y", function() {
          		return 76;			// position at static height below x-axis
          	})
          	.attr("fill", function(){
          		if(result.length > 0)
          			return languageColors(i);
          		else
          			return "#de2d26";
          	})
         	.text( function () {
         		return labelText;
         	});
	}

	function handleTimeViewDateSelection(svg, mousePos, dateLabel)
	{
		// update UI elements in time view
		//

		// remove previous line
		svg.selectAll("#timeViewSelectedDateLine").remove();

		// draw new line
		svg.append("line")
			.attr("id", "timeViewSelectedDateLine")
			.attr("x1", function() {
				return mousePos[0];
			})
			.attr("y1", 10)
			.attr("x2", function() {
				return mousePos[0];
			})
			.attr("y2", streamGraphHeight-sgYAxisPadding)
			.attr("stroke", "#000000")

		// remove previous date text label
		svg.selectAll("#timeViewSelectedDateText").remove();

		// display date text label
		svg.append("text")
			.attr("id", "timeViewSelectedDateText")
			.attr("x", function() {
				var xPos = mousePos[0] + 6;							// + 6 to position slightly to the right of the current mouse position
				if(xPos > streamGraphWidth - 150) xPos = xPos - 70;	// border handling: when too far right, swap to left
				return xPos;
			})
          	.attr("y", function() {
          		return 14;			// position at static height below x-axis
          		//return mousePos[1];
          	})
         	.text( function () {
         		return dateLabel;
         	})
         	.attr("fill", "#000000");
	}

	function removeTimeViewMouseOver(svg){

		// remove line
		svg.selectAll("#timeViewMouseOverLine").remove();

		// remove date text label
		svg.selectAll("#timeViewMouseOverText").remove();
	}
   
	function updateTimeViewMouseOver(svg, mousePos, dateLabel)
	{
		// remove previous line and text
		removeTimeViewMouseOver(svg);

		// draw new line
		svg.append("line")
			.attr("id", "timeViewMouseOverLine")
			.attr("x1", function() {
				return mousePos[0];
			})
			.attr("y1", sgYAxisPadding)
			.attr("x2", function() {
				return mousePos[0];
			})
			.attr("y2", streamGraphHeight-sgYAxisPadding);

		// display date text label
		svg.append("text")
			.attr("id", "timeViewMouseOverText")
			.attr("x", function() {
				var xPos = mousePos[0] + 6;							// + 6 to position slightly to the right of the current mouse position
				if(xPos > streamGraphWidth - 150) xPos = xPos - 76;	// border handling: when too far right, swap to left
				return xPos;		
			})
          	.attr("y", function() {
          		return 60;			// position at static height below x-axis
          		//return mousePos[1];
          	})
         	.text( function () {
         		return dateLabel;
         	});
	}

	function createDateLabelStringFromDate(date)
	{
		// DATA_LOADING_SWITCH
		if(clusterTimeFrequency == "weekly")
		{
			// return weekly date string as is
			return date;
		}
		else if(clusterTimeFrequency == "daily")
		{
			// extract relevant date label components
			var yyyy = date.getFullYear();		// year
			var mm 	 = date.getMonth() + 1;		// january = 0
			var dd   = date.getDate();			// day of the month	

			// handle 0 prefix if neccesary
			if(mm < 10) mm = "0" + mm;
			if(dd < 10) dd = "0" + dd;

			// return yyyy-mm-dd
			return yyyy + "-" + mm + "-" + dd;
		}
	}
	*/
	
	// === TEMPERATURE VIEW ===

	// === Note ===
	// overall adapted from example demonstrated by Gord Lea via 
	// [ https://bl.ocks.org/gordlea/27370d1eea8464b04538e6d8ced39e89 ]

	var temperatureLineChartSVG;	// reference to svg representing the temperature line chart

	// settings for chart svg
	var temperatureLineChartWidth = 800,
		temperatureLineChartHeight = 500,
		templsXAxisMargin = 50,
		templsYAxisMargin = 50,
		templsXAxisPadding = 20,
		templsYAxisPadding = 20;

	var templsXAxisScale;			// ordinal x-axis with time events
	var templsXAxisScaleInvert;		// invert of above

	var lastHoveredTemperatureTimeLabel;	// time label for hover
	var lastHoveredTemperatureMousePos;		// mouse pos of hover

	var currentlySelectedTemperatureTimeEvent = null;				// mouse click selected event
	var currentlySelectedTemperatureTimeRangeEndEvent = null;		// cmd + mouse click selected event for range (in combination with the above)

	var tvMouseXOffset = -4;		// helper function to translate time view's date slider by a few pixels (otherwise the mouse would select the slider svg element all the time)

	function updateTemperatureViewForCountry(country_id)
	{
		// remove all existing svg child elements from the div with the entered ID
		d3.select('#temperatureview').selectAll("svg").remove();

		// margin convention practice 
		var margin = {top: templsYAxisMargin, right: templsXAxisMargin, bottom: templsYAxisMargin, left: templsXAxisMargin}
		  , width = temperatureLineChartWidth - margin.left - margin.right
		  , height = temperatureLineChartHeight - margin.top - margin.bottom;

		// create variable to temperature line chart svg element in view and set it up acccordingly
		temperatureLineChartSVG = d3.select('#temperatureview')
							.append('svg')
								.attr('width', temperatureLineChartWidth + margin.left + margin.right)
								.attr('height', temperatureLineChartHeight + margin.top + margin.bottom)
							.append("g")
		 		   				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		//var  countryFilePath = "data/ad_countries/" + country_id + ".csv";
		var  countryFilePath = globalDataDirectory + country_id + ".csv";
		if (country_id != null)
		{
			// load data
			d3.dsv(",", countryFilePath).then(function(data) {

				//console.log(data)

				// filter loaded data to grab only relevant data
				var temperatureData = data.filter(entry => entry.dimension == 'sunlight');

				// create array with the individual time events representing the scale's domain
				var timeDomain = new Array();
				for(var i = 0; i < temperatureData.length; i++)
				{
					timeDomain.push(temperatureData[i].time);
				}

				// create array with the tick values corresponding to the individual weeks representing the scale's range
				var timeRange = new Array();
				for(var i = 0; i < timeDomain.length; i++)
				{
					var currentRangeValue = templsXAxisPadding + ( (temperatureLineChartWidth-templsXAxisPadding) / timeDomain.length * i); 
					timeRange.push(currentRangeValue);
				}

				// create scale for x-axis
				templsXAxisScale = d3.scaleOrdinal()
									.domain(timeDomain)
									.range(timeRange);

				// create helper scale since ordinal scale do not feature an invert() function
				// note: this is needed to get the domain value from entering a range value (e.g. get week value from hovered pointer in the time line (range value))
				templsXAxisScaleInvert = d3.scaleQuantile()
									.domain(timeRange)
									.range(timeDomain);

				// label only every 16-th item
				var templsXAxisScaleTicks = templsXAxisScale.domain().filter(function(d,i){ return !(i%16); });
				templsXAxisScaleTicks.push(timeDomain[timeDomain.length-1]); // ensure tick for very last item

				// y-axis scale
				var yScale = d3.scaleLinear()
				    .domain([0, 100]) 		// input 
				    .range([height, 0]); 	// output 

				// generate line 
				var line = d3.line()
				    .x(function(d) { return templsXAxisScale(d.time); }) 
				    .y(function(d) { return yScale(d.value); })
				    .curve(d3.curveMonotoneX)

				// x-axis scale
				temperatureLineChartSVG.append("g")
				    .attr("class", "x axis")
				    .attr("transform", "translate(0," + height + ")")
				    .call(d3.axisBottom(templsXAxisScale)
				    		.tickValues(templsXAxisScaleTicks))
				    .selectAll("text")
				    		.attr("transform", "translate(-30,30)rotate(-45)");		// slight translate and rotate all labels 

				// y-axis scale
				temperatureLineChartSVG.append("g")
				    .attr("class", "y axis")
				    .call(d3.axisLeft(yScale))
				    .selectAll("text")
				    		.attr("transform", "translate(-10,0)");		// slight translate all labels 

				// append path, bind data, and call line generator 
				temperatureLineChartSVG.append("path")
				    .datum(temperatureData)  
				    .attr("id", "temperatureViewChartLine")
				    .attr("d", line); 

				temperatureLineChartSVG.append("g")
					.append('text')
		   			.style("font-size", "16px")
		   			.style("text-anchor", "start")
		   			.attr('x', 20)
		   			.attr('y', -10)
		   			.text("Sunlight: " + country_id);	

				// Mouse interaction with TimeView
				// overall adapted from example demonstrated by Paul Sherman via
				// [ https://www.pshrmn.com/tutorials/d3/mouse/ ]
				// and by Mike Bostock via
				// [ https://bl.ocks.org/mbostock/3902569 ]
				// Mouse events tutorial via [ https://www.stator-afm.com/tutorial/d3-js-mouse-events/ ]
		
				// add listener for mouse move event in line chart
				d3.select('#temperatureview').select('svg').on('mousemove', function(){

					// get coordinates from mouse in line chart svg
					var mousePosition = [ d3.mouse(this)[0] + tvMouseXOffset - templsXAxisMargin, d3.mouse(this)[1] ];

					// grab x position and apply border handling based on stream graph x-axis scale
					if(mousePosition[0] >= templsXAxisPadding && mousePosition[0] <= temperatureLineChartWidth)
					{
						// invert the scale to get the domain value
						// for ordinal scale, helper axis is used
						var xDomainValue = templsXAxisScaleInvert(mousePosition[0]);

				  		// update view according to mouse movement
				 		updateTemperatureViewMouseOver(temperatureLineChartSVG, mousePosition, xDomainValue);
					}
				});

				// add listener for mouse leave event in line chart
				d3.select('#temperatureview').select('svg').on('mouseleave', function(){
					removeTemperatureViewMouseOver(temperatureLineChartSVG);
					lastHoveredTemperatureTimeLabel = null;
					lastHoveredTemperatureMousePos = null;
				});

				// add listener for mouse down (= left click) in line chart
				d3.select('#temperatureview').select('svg').on('mousedown', function(){

					// if cmd key is not down: select new time event
					if (isCmdKeyDown == false)
					{
						removeTemperatureTimeRangeSelection(temperatureLineChartSVG);
						selectTemperatureTimeEvent(temperatureLineChartSVG, true, true);
					}
					// else if cmd key is down, and
					// a time event was selected previously, and
					// the selected time event is not the last hovered time event: select time range
					else if (isCmdKeyDown == true &&
						currentlySelectedTemperatureTimeEvent != null &&
						currentlySelectedTemperatureTimeEvent != lastHoveredTemperatureTimeLabel)
					{
						//console.log('select time range: ' + currentlySelectedTemperatureTimeEvent + '  <---> ' + lastHoveredTemperatureTimeLabel);

						selectTemperatureTimeRange(temperatureLineChartSVG, true, true);
					}
				});

				// NETWORKING (handle sync with VR user status)
				if (lastVRUserSelectedTimeEvent != null) VR_updateSelectedTimeEvent(lastVRUserSelectedTimeEvent);
				if (lastVRUserSelectedTimeRangeStart != null && lastVRUserSelectedTimeRangeEnd != null) VR_updateSelectedTimeRange(lastVRUserSelectedTimeRangeStart, lastVRUserSelectedTimeRangeEnd);

			});
		}
		// no data available, or counry_id parameter was invalid (= no file found)
		else
		{
				temperatureLineChartSVG.append("g")
					.append('text')
		   			.style("font-size", "16px")
		   			.style("text-anchor", "start")
		   			.attr('x', 20)
		   			.attr('y', -10)
		   			.text("Sunlight: No country selected.");		
		}
	}
	
	function updateTemperatureViewMouseOver(svg, mousePos, dateLabel)
	{
		// keep track globally about hover status
		lastHoveredTemperatureTimeLabel = dateLabel;
		lastHoveredTemperatureMousePos = mousePos;

		// remove previous line and text
		removeTemperatureViewMouseOver(svg);

		// draw new line
		svg.append("line")
			.attr("id", "temperatureViewMouseOverLine")
			.attr("x1", function() {
				return mousePos[0];
			})
			.attr("y1", 0)
			.attr("x2", function() {
				return mousePos[0];
			})
			.attr("y2", temperatureLineChartHeight-templsYAxisMargin*2);
	
		// display date text label
		svg.append("text")
			.attr("id", "temperatureViewMouseOverText")
			.attr("x", function() {
				var xPos = mousePos[0] + 6;										// + 6 to position slightly to the right of the current mouse position
				if(xPos > temperatureLineChartWidth - 100) xPos = xPos - 76;	// border handling: when too far right, swap to left
				return xPos;		
			})
          	.attr("y", function() {
          		return 20;			// position at static height towards the top
          	})
         	.text( function () {
         		return dateLabel;
         	});
	}

	function removeTemperatureViewMouseOver(svg){

		// remove line
		svg.selectAll("#temperatureViewMouseOverLine").remove();

		// remove date text label
		svg.selectAll("#temperatureViewMouseOverText").remove();
	}

	function selectTemperatureTimeEvent(svg, isViewSyncEnabled, shouldTriggerNetworkUpdate)
	{
		removeTemperatureViewSelection(svg);

		if (lastHoveredTemperatureTimeLabel != null && lastHoveredTemperatureMousePos != null)
		{
			// store time reference
			currentlySelectedTemperatureTimeEvent = lastHoveredTemperatureTimeLabel;

			// draw new line
			svg.append("line")
				.attr("id", "temperatureViewSelectedDateLine")
				.attr("x1", function() {
					return lastHoveredTemperatureMousePos[0];
				})
				.attr("y1", 0)
				.attr("x2", function() {
					return lastHoveredTemperatureMousePos[0];
				})
				.attr("y2", temperatureLineChartHeight-templsYAxisMargin*2);

			// display date text label
			svg.append("text")
				.attr("id", "temperatureViewSelectedDateText")
				.attr("x", function() {
					var xPos = lastHoveredTemperatureMousePos[0] + 6;				// + 6 to position slightly to the right of the current mouse position
					if(xPos > temperatureLineChartWidth - 100) xPos = xPos - 76;	// border handling: when too far right, swap to left
					return xPos;		
				})
	          	.attr("y", function() {
	          		return 20;			// position at static height towards the top
	          	})
	         	.text( function () {
	         		return lastHoveredTemperatureTimeLabel;
	         	});

	        // TEMPERATURE-HUMIDITY-VIEW-SYNC
         	if (isViewSyncEnabled)
         	{
	         	lastHoveredHumidityTimeLabel = lastHoveredTemperatureTimeLabel;
	         	lastHoveredHumidityMousePos = lastHoveredTemperatureMousePos;
     			removeHumidityTimeRangeSelection(humidityLineChartSVG);
				selectHumidityTimeEvent(humidityLineChartSVG, false, false);
			}

			// NETWORKING
			if (shouldTriggerNetworkUpdate)
			{
				networking_js2unity_temporalReferenceSingle(currentlySelectedClusterID, lastHoveredTemperatureTimeLabel);
			}
		}
	}

	function removeTemperatureViewSelection(svg){

		// remove line
		svg.selectAll("#temperatureViewSelectedDateLine").remove();

		// remove date text label
		svg.selectAll("#temperatureViewSelectedDateText").remove();
	}

	function selectTemperatureTimeRange(svg, isViewSyncEnabled, shouldTriggerNetworkUpdate)
	{
		removeTemperatureTimeRangeSelection(svg);

		if (lastHoveredTemperatureTimeLabel != null && lastHoveredTemperatureMousePos != null)
		{
			// store time reference
			currentlySelectedTemperatureTimeRangeEndEvent = lastHoveredTemperatureTimeLabel;

			// determine rect stats
			var xSelection = d3.select("#temperatureViewSelectedDateLine").attr("x1");
			var xHover = lastHoveredTemperatureMousePos[0];

			var x = (xSelection < xHover) ? xSelection : xHover;
			var width = (xSelection < xHover) ? xHover - xSelection : xSelection - xHover;

			//svg.append('rect')
			svg.insert('rect', "path.line")	// insert before chart line in hierarchy (path elemtn of class line --> path.line)
			  .attr("id", "temperatureViewTimeRangeSelectionRect")
			  .attr('x', x)
			  .attr('y', 0)
			  .attr('width', width)
			  .attr('height', temperatureLineChartHeight-templsYAxisMargin*2);

			
			// draw new line for range
			//svg.append("line")
			svg.insert('line', "path.line")
				.attr("id", "temperatureViewSelectedRangeDateLine")
				.attr("x1", function() {
					return lastHoveredTemperatureMousePos[0];
				})
				.attr("y1", 0)
				.attr("x2", function() {
					return lastHoveredTemperatureMousePos[0];
				})
				.attr("y2", temperatureLineChartHeight-templsYAxisMargin*2);

			// display date text label for range
			//svg.append("text")
			svg.insert('text', "path.line")
				.attr("id", "temperatureViewSelectedRangeDateText")
				.attr("x", function() {
					var xPos = lastHoveredTemperatureMousePos[0] + 6;				// + 6 to position slightly to the right of the current mouse position
					if(xPos > temperatureLineChartWidth - 100) xPos = xPos - 76;	// border handling: when too far right, swap to left
					return xPos;		
				})
	          	.attr("y", function() {
	          		return 40;			// position at static height towards the top
	          	})
	         	.text( function () {
	         		return lastHoveredTemperatureTimeLabel;
	         	});

	        // TEMPERATURE-HUMIDITY-VIEW-SYNC
         	if (isViewSyncEnabled)
         	{
	         	lastHoveredHumidityTimeLabel = lastHoveredTemperatureTimeLabel;
	         	lastHoveredHumidityMousePos = lastHoveredTemperatureMousePos;
				selectHumidityTimeRange(humidityLineChartSVG, false, false);
			}

			// NETWORKING
			if (shouldTriggerNetworkUpdate)
			{
				// validate range selection parameters
				var timeRangeStart = currentlySelectedTemperatureTimeEvent;
				var timeRangeEnd = lastHoveredTemperatureTimeLabel;

				var trsX = templsXAxisScale(timeRangeStart);
				var treX = templsXAxisScale(timeRangeEnd);
				if (treX < trsX)
				{
					var temp = timeRangeStart;
					timeRangeStart = timeRangeEnd;
					timeRangeEnd = temp;
				}
				//console.log(timeRangeStart + "  <----->  " + timeRangeEnd);

				networking_js2unity_temporalReferenceRange(currentlySelectedClusterID, timeRangeStart, timeRangeEnd);
			}
		}
	}

	function removeTemperatureTimeRangeSelection(svg)
	{
		svg.selectAll("#temperatureViewTimeRangeSelectionRect").remove();
		svg.selectAll("#temperatureViewSelectedRangeDateLine").remove();
		svg.selectAll("#temperatureViewSelectedRangeDateText").remove();
	}


	// === HUMIDITY VIEW === (pretty much copied 1-to-1 from TEMPERATURE VIEW)

	// === Note ===
	// overall adapted from example demonstrated by Gord Lea via 
	// [ https://bl.ocks.org/gordlea/27370d1eea8464b04538e6d8ced39e89 ]

	var humidityLineChartSVG;	// reference to svg representing the temperature line chart

	// settings for chart svg
	var humidityLineChartWidth = 800,
		humidityLineChartHeight = 500,
		humlsXAxisMargin = 50,
		humlsYAxisMargin = 50,
		humlsXAxisPadding = 20,
		humlsYAxisPadding = 20;

	var humlsXAxisScale;			// ordinal x-axis with time events
	var humlsXAxisScaleInvert;		// invert of above

	var lastHoveredHumidityTimeLabel;	// time label for hover
	var lastHoveredHumidityMousePos;		// mouse pos of hover

	var currentlySelectedHumidityTimeEvent = null;				// mouse click selected event
	var currentlySelectedHumidityTimeRangeEndEvent = null;		// cmd + mouse click selected event for range (in combination with the above)

	//var tvMouseXOffset = -4;		// helper function to translate time view's date slider by a few pixels (otherwise the mouse would select the slider svg element all the time)

	function updateHumidityViewForCountry(country_id)
	{
		// remove all existing svg child elements from the div with the entered ID
		d3.select('#humidityview').selectAll("svg").remove();

		// margin convention practice 
		var margin = {top: humlsYAxisMargin, right: humlsXAxisMargin, bottom: humlsYAxisMargin, left: humlsXAxisMargin}
		  , width = humidityLineChartWidth - margin.left - margin.right
		  , height = humidityLineChartHeight - margin.top - margin.bottom;

		// create variable to temperature line chart svg element in view and set it up acccordingly
		humidityLineChartSVG = d3.select('#humidityview')
							.append('svg')
								.attr('width', humidityLineChartWidth + margin.left + margin.right)
								.attr('height', humidityLineChartHeight + margin.top + margin.bottom)
							.append("g")
		 		   				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		//var  countryFilePath = "data/ad_countries/" + country_id + ".csv";
		var  countryFilePath = globalDataDirectory + country_id + ".csv";
		if (country_id != null)
		{
			// load data
			d3.dsv(",", countryFilePath).then(function(data) {

				//console.log(data)

				// filter loaded data to grab only relevant data
				var humidityData = data.filter(entry => entry.dimension == 'humidity');

				// create array with the individual time events representing the scale's domain
				var timeDomain = new Array();
				for(var i = 0; i < humidityData.length; i++)
				{
					timeDomain.push(humidityData[i].time);
				}

				// create array with the tick values corresponding to the individual weeks representing the scale's range
				var timeRange = new Array();
				for(var i = 0; i < timeDomain.length; i++)
				{
					var currentRangeValue = humlsXAxisPadding + ( (humidityLineChartWidth-humlsXAxisPadding) / timeDomain.length * i); 
					timeRange.push(currentRangeValue);
				}

				// create scale for x-axis
				humlsXAxisScale = d3.scaleOrdinal()
									.domain(timeDomain)
									.range(timeRange);

				// create helper scale since ordinal scale do not feature an invert() function
				// note: this is needed to get the domain value from entering a range value (e.g. get week value from hovered pointer in the time line (range value))
				humlsXAxisScaleInvert = d3.scaleQuantile()
									.domain(timeRange)
									.range(timeDomain);

				// label only every 16-th item
				var humlsXAxisScaleTicks = humlsXAxisScale.domain().filter(function(d,i){ return !(i%16); });
				humlsXAxisScaleTicks.push(timeDomain[timeDomain.length-1]); // ensure tick for very last item

				// y-axis scale
				var yScale = d3.scaleLinear()
				    .domain([0, 100]) 		// input 
				    .range([height, 0]); 	// output 

				// generate line 
				var line = d3.line()
				    .x(function(d) { return humlsXAxisScale(d.time); }) 
				    .y(function(d) { return yScale(d.value); })
				    .curve(d3.curveMonotoneX)

				// x-axis scale
				humidityLineChartSVG.append("g")
				    .attr("class", "x axis")
				    .attr("transform", "translate(0," + height + ")")
				    .call(d3.axisBottom(humlsXAxisScale)
				    		.tickValues(humlsXAxisScaleTicks))
				    .selectAll("text")
				    		.attr("transform", "translate(-30,30)rotate(-45)");		// slight translate and rotate all labels 

				// y-axis scale
				humidityLineChartSVG.append("g")
				    .attr("class", "y axis")
				    .call(d3.axisLeft(yScale))
				    .selectAll("text")
				    		.attr("transform", "translate(-10,0)");		// slight translate all labels 

				// append path, bind data, and call line generator 
				humidityLineChartSVG.append("path")
				    .datum(humidityData)  
				    .attr("id", "humidityViewChartLine")
				    .attr("d", line); 

				// add caption
		   		humidityLineChartSVG.append("g")
					.append('text')
		   			.style("font-size", "16px")
		   			.style("text-anchor", "start")
		   			.attr('x', 20)
		   			.attr('y', -10)
		   			.text("Humidity: " + country_id);	

				// Mouse interaction with TimeView
				// overall adapted from example demonstrated by Paul Sherman via
				// [ https://www.pshrmn.com/tutorials/d3/mouse/ ]
				// and by Mike Bostock via
				// [ https://bl.ocks.org/mbostock/3902569 ]
				// Mouse events tutorial via [ https://www.stator-afm.com/tutorial/d3-js-mouse-events/ ]
		
				// add listener for mouse move event in line chart
				d3.select('#humidityview').select('svg').on('mousemove', function(){

					// get coordinates from mouse in line chart svg
					var mousePosition = [ d3.mouse(this)[0] + tvMouseXOffset - humlsXAxisMargin, d3.mouse(this)[1] ];

					// grab x position and apply border handling based on stream graph x-axis scale
					if(mousePosition[0] >= humlsXAxisPadding && mousePosition[0] <= humidityLineChartWidth)
					{
						// invert the scale to get the domain value
						// for ordinal scale, helper axis is used
						var xDomainValue = humlsXAxisScaleInvert(mousePosition[0]);

				  		// update view according to mouse movement
				 		updateHumidityViewMouseOver(humidityLineChartSVG, mousePosition, xDomainValue);
					}
				});

				// add listener for mouse leave event in line chart
				d3.select('#humidityview').select('svg').on('mouseleave', function(){
					removeHumidityViewMouseOver(humidityLineChartSVG);
					lastHoveredHumidityTimeLabel = null;
					lastHoveredHumidityMousePos = null;
				});

				// add listener for mouse down (= left click) in line chart
				d3.select('#humidityview').select('svg').on('mousedown', function(){

					// if cmd key is not down: select new time event
					if (isCmdKeyDown == false)
					{
						removeHumidityTimeRangeSelection(humidityLineChartSVG);
						selectHumidityTimeEvent(humidityLineChartSVG, true, true);
					}
					// else if cmd key is down, and
					// a time event was selected previously, and
					// the selected time event is not the last hovered time event: select time range
					else if (isCmdKeyDown == true &&
						currentlySelectedHumidityTimeEvent != null &&
						currentlySelectedHumidityTimeEvent != lastHoveredHumidityTimeLabel)
					{
						//console.log('select time range: ' + currentlySelectedTemperatureTimeEvent + '  <---> ' + lastHoveredTemperatureTimeLabel);

						selectHumidityTimeRange(humidityLineChartSVG, true, true);
					}
				});

				// DEBUG TODO REMOVE - VR user info
				//VR_removeAllSelectedTimeInformation();
				//VR_updateSelectedTimeEvent("2021-06-02");
				//VR_updateSelectedTimeRange("2021-05-01", "2021-07-04");

				// NETWORKING (handle sync with VR user status)
				if (lastVRUserSelectedTimeEvent != null) VR_updateSelectedTimeEvent(lastVRUserSelectedTimeEvent);
				if (lastVRUserSelectedTimeRangeStart != null && lastVRUserSelectedTimeRangeEnd != null) VR_updateSelectedTimeRange(lastVRUserSelectedTimeRangeStart, lastVRUserSelectedTimeRangeEnd);
			});
		}
		// no data available, or counry_id parameter was invalid (= no file found)
		else
		{
	   		humidityLineChartSVG.append("g")
				.append('text')
	   			.style("font-size", "16px")
	   			.style("text-anchor", "start")
	   			.attr('x', 20)
	   			.attr('y', -10)
	   			.text("Humidity: No country selected.");		
		}
	}
	
	function updateHumidityViewMouseOver(svg, mousePos, dateLabel)
	{
		// keep track globally about hover status
		lastHoveredHumidityTimeLabel = dateLabel;
		lastHoveredHumidityMousePos = mousePos;

		// remove previous line and text
		removeHumidityViewMouseOver(svg);

		// draw new line
		svg.append("line")
			.attr("id", "humidityViewMouseOverLine")
			.attr("x1", function() {
				return mousePos[0];
			})
			.attr("y1", 0)
			.attr("x2", function() {
				return mousePos[0];
			})
			.attr("y2", humidityLineChartHeight-humlsYAxisMargin*2);
	
		// display date text label
		svg.append("text")
			.attr("id", "humidityViewMouseOverText")
			.attr("x", function() {
				var xPos = mousePos[0] + 6;										// + 6 to position slightly to the right of the current mouse position
				if(xPos > humidityLineChartWidth - 100) xPos = xPos - 76;	// border handling: when too far right, swap to left
				return xPos;		
			})
          	.attr("y", function() {
          		return 20;			// position at static height towards the top
          	})
         	.text( function () {
         		return dateLabel;
         	});
	}

	function removeHumidityViewMouseOver(svg){

		// remove line
		svg.selectAll("#humidityViewMouseOverLine").remove();

		// remove date text label
		svg.selectAll("#humidityViewMouseOverText").remove();
	}

	function selectHumidityTimeEvent(svg, isViewSyncEnabled, shouldTriggerNetworkUpdate)
	{
		removeHumidityViewSelection(svg);

		if (lastHoveredHumidityTimeLabel != null && lastHoveredHumidityMousePos != null)
		{
			// store time reference
			currentlySelectedHumidityTimeEvent = lastHoveredHumidityTimeLabel;

			// draw new line
			svg.append("line")
				.attr("id", "humidityViewSelectedDateLine")
				.attr("x1", function() {
					return lastHoveredHumidityMousePos[0];
				})
				.attr("y1", 0)
				.attr("x2", function() {
					return lastHoveredHumidityMousePos[0];
				})
				.attr("y2", humidityLineChartHeight-humlsYAxisMargin*2);

			// display date text label
			svg.append("text")
				.attr("id", "humidityViewSelectedDateText")
				.attr("x", function() {
					var xPos = lastHoveredHumidityMousePos[0] + 6;				// + 6 to position slightly to the right of the current mouse position
					if(xPos > humidityLineChartWidth - 100) xPos = xPos - 76;	// border handling: when too far right, swap to left
					return xPos;		
				})
	          	.attr("y", function() {
	          		return 20;			// position at static height towards the top
	          	})
	         	.text( function () {
	         		return lastHoveredHumidityTimeLabel;
	         	});

         	// TEMPERATURE-HUMIDITY-VIEW-SYNC
         	if (isViewSyncEnabled)
         	{
	         	lastHoveredTemperatureTimeLabel = lastHoveredHumidityTimeLabel;
	         	lastHoveredTemperatureMousePos = lastHoveredHumidityMousePos;
     			removeTemperatureTimeRangeSelection(temperatureLineChartSVG);
				selectTemperatureTimeEvent(temperatureLineChartSVG, false, false);
			}

			// NETWORKING
			if (shouldTriggerNetworkUpdate)
			{
				networking_js2unity_temporalReferenceSingle(currentlySelectedClusterID, lastHoveredHumidityTimeLabel);
			}
		}
	}

	function removeHumidityViewSelection(svg){

		// remove line
		svg.selectAll("#humidityViewSelectedDateLine").remove();

		// remove date text label
		svg.selectAll("#humidityViewSelectedDateText").remove();
	}

	function selectHumidityTimeRange(svg, isViewSyncEnabled, shouldTriggerNetworkUpdate)
	{
		removeHumidityTimeRangeSelection(svg);

		if (lastHoveredHumidityTimeLabel != null && lastHoveredHumidityMousePos != null)
		{
			// store time reference
			currentlySelectedHumidityTimeRangeEndEvent = lastHoveredHumidityTimeLabel;

			// determine rect stats
			var xSelection = d3.select("#humidityViewSelectedDateLine").attr("x1");
			var xHover = lastHoveredHumidityMousePos[0];

			var x = (xSelection < xHover) ? xSelection : xHover;
			var width = (xSelection < xHover) ? xHover - xSelection : xSelection - xHover;

			//svg.append('rect')
			svg.insert('rect', "path.line")	// insert before chart line in hierarchy (path elemtn of class line --> path.line)
			  .attr("id", "humidityViewTimeRangeSelectionRect")
			  .attr('x', x)
			  .attr('y', 0)
			  .attr('width', width)
			  .attr('height', humidityLineChartHeight-humlsYAxisMargin*2);

			
			// draw new line for range
			//svg.append("line")
			svg.insert('line', "path.line")
				.attr("id", "humidityViewSelectedRangeDateLine")
				.attr("x1", function() {
					return lastHoveredHumidityMousePos[0];
				})
				.attr("y1", 0)
				.attr("x2", function() {
					return lastHoveredHumidityMousePos[0];
				})
				.attr("y2", humidityLineChartHeight-humlsYAxisMargin*2);

			// display date text label for range
			//svg.append("text")
			svg.insert('text', "path.line")
				.attr("id", "humidityViewSelectedRangeDateText")
				.attr("x", function() {
					var xPos = lastHoveredHumidityMousePos[0] + 6;				// + 6 to position slightly to the right of the current mouse position
					if(xPos > humidityLineChartWidth - 100) xPos = xPos - 76;	// border handling: when too far right, swap to left
					return xPos;		
				})
	          	.attr("y", function() {
	          		return 40;			// position at static height towards the top
	          	})
	         	.text( function () {
	         		return lastHoveredHumidityTimeLabel;
	         	});

         	// TEMPERATURE-HUMIDITY-VIEW-SYNC
         	if (isViewSyncEnabled)
         	{
	         	lastHoveredTemperatureTimeLabel = lastHoveredHumidityTimeLabel;
	         	lastHoveredTemperatureMousePos = lastHoveredHumidityMousePos;
				selectTemperatureTimeRange(temperatureLineChartSVG, false, false);
			}

			// NETWORKING
			if (shouldTriggerNetworkUpdate)
			{
				// validate range selection parameters
				var timeRangeStart = currentlySelectedHumidityTimeEvent;
				var timeRangeEnd = lastHoveredHumidityTimeLabel;

				var trsX = templsXAxisScale(timeRangeStart);
				var treX = templsXAxisScale(timeRangeEnd);
				if (treX < trsX)
				{
					var temp = timeRangeStart;
					timeRangeStart = timeRangeEnd;
					timeRangeEnd = temp;
				}
				//console.log(timeRangeStart + "  <----->  " + timeRangeEnd);

				networking_js2unity_temporalReferenceRange(currentlySelectedClusterID, timeRangeStart, timeRangeEnd);
			}
		}
	}

	function removeHumidityTimeRangeSelection(svg)
	{
		svg.selectAll("#humidityViewTimeRangeSelectionRect").remove();
		svg.selectAll("#humidityViewSelectedRangeDateLine").remove();
		svg.selectAll("#humidityViewSelectedRangeDateText").remove();
	}


	// === GLOBAL KEYDOWN "CMD" STATUS ===

	var isCmdKeyDown = false;

	d3.select("body")
	    .on("keydown", function() {

	    	//console.log('keydown');
	    	//console.log(d3.event.keyCode);

	    	// Mac: CMD keycode == 91
	    	if (d3.event.keyCode == 91) isCmdKeyDown = true;

	    	// Windows: CRTL keybode == 17
	    	if (d3.event.keyCode == 17) isCmdKeyDown = true;
	    });

	d3.select("body")
	    .on("keyup", function() {

	    	//console.log('keyup');
	    	//console.log(d3.event.keyCode);

	    	if (d3.event.keyCode == 91) isCmdKeyDown = false;
	    	if (d3.event.keyCode == 17) isCmdKeyDown = false;
	    });


	/*
	// === DATA SELECTION AND LOADING ===

	function grabClusterFileForDate(date)
	{
		// DATA_LOADING_SWITCH
		if (clusterTimeFrequency == "weekly")
		{
			//build file name
			var filePrefix = date;
			var fileSuffix = " cluster languages.csv";
			var fileName = filePrefix + fileSuffix;
			var filePath = "data/weekly/cluster_demoht18_lang/" + fileName;
		}
		else if (clusterTimeFrequency == "daily")
		{
			//build file name
			var filePrefix = date;
			var fileSuffix = " cluster languages.csv";
			var fileName = filePrefix + fileSuffix;
			var filePath = "data/daily/cluster_demovt18_lang/" + fileName;
		}

		//console.log(fileName);
		//console.log(filePath);
		
		return filePath;
	}
	*/

/*
	function updateViewsForNoDataAvailable()
	{
		// map view
		// handled within map view drawing

		// cluster detail view
		//updateClusterDetailViewForCluster(null, null);

		// places view
		updatePlacesViewForForCluster(null);

		// time view
		// mark time selector red, indicating that data is not available for the selected day
		//streamGraphSVG.selectAll("#timeViewSelectedDateLine").attr("stroke", "#de2d26");
		//streamGraphSVG.selectAll("#timeViewSelectedDateText").attr("fill", "#de2d26");
	}
	*/
	
	// === DATA LOADING SWITCH ===
	// demo-vt18 = daily  (set through URL argument)
	// demo-ht18 = weekly (default)
	// Note: All function calls are tagged as 'DATA_LOADING_SWITCH' wherever applied (for better findability)

	/*
	var clusterTimeFrequency = "weekly";	
	//var dataCTF = appURL.searchParams.get("ctf");			// extract url argument "ctf"
	//if(dataCTF == "daily") clusterTimeFrequency = "daily";


	// === SETUP START-UP STATE OF APPLICATION (hardcoded) === 
	// DATA_LOADING_SWITCH
	if(clusterTimeFrequency == "weekly")
	{
		currentlySelectedClusterID = 70;						// 70 -> Gotland, 112 -> Vxj
		currentlySelectedTimeMousePos = [662, 242];
		currentlySelectedTimeDateLabel = "2017-w18";
	}
	else if(clusterTimeFrequency == "daily") {
		currentlySelectedClusterID = 70;						// 70 -> Gotland, 112 -> Vxj
		currentlySelectedTimeMousePos = [279, 242];
		currentlySelectedTimeDateLabel = "2017-01-15";

		// ODXVRxNTS study init for Friday, 21.09.2018

		// get task parameter from app url (created within NETWORKING section) and override (if exsiting) initial startup state of application
		var task = appURL.searchParams.get("task");			// extract url argument "task"
		if(task == "christmas")
		{
			currentlySelectedClusterID = 112;						// 112 -> Vxj
			currentlySelectedTimeMousePos = [1380, 242];
			currentlySelectedTimeDateLabel = "2017-12-20";
		}
		else if(task == "midsummer")
		{
			currentlySelectedClusterID = 112;						// 112 -> Vxj
			currentlySelectedTimeMousePos = [780, 242];
			currentlySelectedTimeDateLabel = "2017-06-18";
		}
	}
	*/
	var currentlySelectedClusterID = "";						


	// LOGGING (places in the source code related to the logging are commented with 'LOGGING')
	// get logging parameter from app url (created within NETWORKING section) and setup initial startup state of application
	var shouldLog = false;
	//var logs = appURL.searchParams.get("logs");			// extract url argument "logs"
	//if(logs == "true") shouldLog = true;

	if(shouldLog)
	{
		var logging_numberOfNodeSelections = 0;
		var logging_numberOfTimeSelections = 0;

		function logNumberOfNodeSelections()
		{
			logging_numberOfNodeSelections += 1;
			console.log('[NODE] Number of node selections = ' + logging_numberOfNodeSelections + ' | ' + new Date());
		}

		function logNumberOfTimeSelections()
		{
			logging_numberOfTimeSelections += 1;
			console.log('[TIME] Number of time selections = ' + logging_numberOfTimeSelections + ' | ' + new Date());
		}		
	}

	// === INITIALIZE VIEWS WITH START-UP CONDITIONS ===

	// DEBUG initial vis at start up
	//updateMapViewForDate(currentlySelectedTimeDateLabel);
	updateMapViewWithCentroids();

    // DEBUG initial vis at start up
	//updateClusterDetailViewForCluster(currentlySelectedClusterID);

    // DEBUG initial vis at start up
	//updatePlacesViewForForCluster(null);

    // DEBUG initial vis at start up
	//updateTimeViewForCluster(currentlySelectedClusterID);
	updateTemperatureViewForCountry(null);
	updateHumidityViewForCountry(null);

	
	// DEBUG initial vis at start up
	if(shouldConnectToWebSocketServer)
	{
		drawVRUserNode();
		//updateVRUserNode();
	}

	</script>
	<!-- D3.js visualization implementation END. -->

</body>

</html>
